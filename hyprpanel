#!/usr/bin/env python3
import os
from pathlib import Path

os.environ["GI_TYPELIB_PATH"] = "/usr/include/hyprpanel/src"

from ctypes import CDLL

CDLL("libgtk4-layer-shell.so")
import subprocess
from subprocess import Popen
from subprocess import check_output, call
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")

from src.core.create_panel import *
import asyncio
from gi.repository import Gtk, Adw, GLib, Gio, Gdk
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from datetime import datetime
import json
import sys
import importlib
import requests
import random
import numpy as np

spam_loader = importlib.util.find_spec("hyprpy")
found = spam_loader is not None

if not found:
    print("Module hyprpy not found, try | pip install hyprpy | and try again")
    sys.exit()

from hyprpy import Hyprland
from multiprocessing import Process
from hyprpy.utils.signals import Signal
import psutil
import math
import pulsectl
import toml
from collections import ChainMap
from src.plugins.dockbar import Dockbar
from src.core.utils import Utils
from src.core.dashboard import Dashboard


class Panel(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
 
        # Initialize utilities and connect to activation event
        self._initialize_utilities()
        self.connect("activate", self.on_activate)

        # Setup panel boxes
        self._setup_panel_boxes()

        # Monitor dimensions and volume controls
        self.monitor_width, self.monitor_height = 0, 0
        self.toggle_mute = {}
        self.volume = 0
        self.clock_box = Gtk.Box()
        self.args = sys.argv

        # Configuration paths
        self._setup_config_paths()

        # Load configurations
        self.panel_cfg = self.load_topbar_config()
        self.icon_theme_list = Gtk.IconTheme().get_icon_names()
        self.active_window_changed = None
        self.notifications = []
        self.popover_bookmarks = None
        self.popover_launcher = None 
        self.popover_clipboard = None
        self.popover_wallpaper = None
        self.clipboard_text_copy = None
        self.active_window_changed = None
        self.hyprpanel_started_now = True

    def _initialize_utilities(self):
        """Initialize utility functions and properties."""
        self.utils = Utils(application_id="com.github.utils")

    def _setup_panel_boxes(self):
        """Setup panel boxes and related configurations."""
        self.top_panel_box_left = Gtk.Box(spacing=10)
        self.top_panel_box_systray = Gtk.Box(spacing=2)
        self.top_panel_box_for_buttons = Gtk.Box(spacing=6)
        self.top_panel_box_right = Gtk.Box(spacing=10)
        self.top_panel_grid_right = Gtk.Grid(column_spacing=10)
        self.top_panel_grid_right.attach(self.top_panel_box_right, 1, 0, 1, 2)
        self.top_panel_grid_right.attach_next_to(
            self.top_panel_box_systray, self.top_panel_box_right, Gtk.PositionType.RIGHT, 1, 2
        )
        self.top_panel_grid_right.attach_next_to(
            self.top_panel_box_for_buttons, self.top_panel_box_systray, Gtk.PositionType.RIGHT, 1, 2
        )

        self.top_panel_box_center = Gtk.Box(spacing=6)
        self.top_panel_box_full = Gtk.Grid()
        self.top_panel_box_full.set_column_homogeneous(True)
        self.top_panel_box_full.attach(self.top_panel_box_left, 1, 0, 1, 2)
        self.top_panel_box_full.attach_next_to(
            self.top_panel_box_center, self.top_panel_box_left, Gtk.PositionType.RIGHT, 1, 2
        )
        self.top_panel_box_full.attach_next_to(
            self.top_panel_grid_right, self.top_panel_box_center, Gtk.PositionType.RIGHT, 1, 3
        )
        # Dockbar and icon themes
        self.dock = Dockbar(application_id="com.github.dockbar")

    def _setup_config_paths(self):
        """Set up configuration paths based on the user's home directory."""
        self.home = os.path.expanduser("~")
        self.scripts = os.path.join(self.home, ".config/hypr/scripts")
        self.config_path = os.path.join(self.home, ".config/hyprpanel")
        self.dockbar_config = os.path.join(self.config_path, "dockbar.toml")
        self.style_css_config = os.path.join(self.config_path, "style.css")
        self.workspace_list_config = os.path.join(self.config_path, "workspacebar.toml")
        self.topbar_config = os.path.join(self.config_path, "panel.toml")
        self.menu_config = os.path.join(self.config_path, "menu.toml")
        self.window_notes_config = os.path.join(self.config_path, "window-config.toml")
        self.cmd_config = os.path.join(self.config_path, "cmd.toml")
        self.topbar_launcher_config  = os.path.join(self.config_path, "topbar-launcher.toml")
        self.cache_folder = os.path.join(self.home, ".cache/hyprpanel")
        self.psutil_store = {}

    def on_activate(self, app):
        self.instance = self.HyprlandInstance()
        self.monitor_width_height()
        # start cmd output session, cmd.toml
        self.cmd_output()
        self.close_fullscreen_buttons()
        self.right_position_launcher_topbar()
        self.setup_panels()
        self.setup_clock_widget()
        self.update_widget_with_timeout()
        self.setup_background_panel_widgets()
        self.setup_panel_buttons()
        self.setup_panel_position()
        self.setup_gestures()
        self.freedesktop_notifications()
        self.create_popover_menu_clipboard(app)
        self.create_menu_popover_launcher(app)
        self.create_menu_popover_bookmarks(app)
        self.create_menu_popover_wallpaper(app)
        
    def do_activate(self):
        self.show_panels()

    def freedesktop_notifications(self):
        DBusGMainLoop(set_as_default=True)
        bus = dbus.SessionBus()
        string = (
            "interface='org.freedesktop.Notifications',member='Notify', eavesdrop='true'"
        )
        #bus.add_match_string(string)
        #bus.add_message_filter(self.notification_msg)

    def monitor_width_height(self):
        # get monitor info and set the width, height for the panel
        monitor_info = self.get_monitor_info()
        for monitor_name in monitor_info:
            if self.instance.get_monitor_by_name(name=monitor_name).is_focused:
                self.monitor_width, self.monitor_height = monitor_info[monitor_name]

    def notification_msg(self, bus, msg):
        m = [str(m) for m in msg.get_args_list() if type(m) == dbus.String]
        notification = " ".join(m)

        #self.notifications.append(notification)
        with open("/tmp/hyprpanel-notifications.txt","a") as file:
            file.write("{0}\n".format(notification))
            file.close()
        with open("/tmp/hyprpanel-notifications.txt","r") as file:
            #print(file.readlines())
            print("")
                   
    def setup_menus(self):
        for menu in self.menus.values():
            self.top_panel_box_systray.append(menu)
            menu.add_css_class("systray")
            self.top_panel_box_systray.set_halign(Gtk.Align.END)
            self.top_panel_box_systray.set_hexpand(True)
        
    def setup_background_panel_widgets(self):
        # notes label
        self.todo_button = Adw.ButtonContent()
        self.todo_button.add_css_class("todo_label")
        self.todo_button.set_icon_name("todoist-symbolic")
        todo = os.path.join(self.home, "Documentos", "todo.txt")

        try:
            txt = open(todo, "r").readlines()[-1]
            self.todo_button.set_label(txt.strip())
            GLib.timeout_add(600000, self.todo_txt)
        except IndexError:
            print("todo.txt is empity or does not exist")
        
        self.tbbox = Gtk.Box(spacing=20)
        self.tblabelspace = Gtk.Label(label="    ")
        self.tbworkspace = self.utils.btn_background(
            "tbworkspace", "gnome-panel-workspace-switcher"
        )
        self.tbpid = self.utils.btn_background("tbpid", "view-process-system")
        self.tbclass = self.utils.btn_background("tbclass", "cs-windows-symbolic")
        self.tbcpusage = self.utils.btn_background(
            "tbcpusage", "cpu"
        )
        self.tbmemusage = self.utils.btn_background(
            "tbmemusage", "media-memory"
        )
        self.tbsinkinput = self.utils.btn_background(
            "tbsinkinput", "multimedia-volume-control-symbolic"
        )
        self.tbSIGKILL = self.utils.btn_background("tbSIGKILL", "window-close-symbolic")
        self.tbdiskusage = self.utils.btn_background(
            "tbdiskusage", "disk-usage-analyzer"
        )
        self.tbvol = self.utils.btn_background(
            "tbvol", "audio-volume-high-symbolic"
        )
        self.tbcard = self.utils.btn_background("tbvoltbcard", "audio-card")
        self.tbdiskusage.set_label("Disk Usage")
        self.tbsinkinput.set_label("Toggle Mute")
        self.tbvol.set_label("Volume")
        self.tbSIGKILL.set_label("SIGKILL")
        self.tbexe = self.utils.btn_background("tbexe", "exec")
        self.tbbox.append(self.tblabelspace)
        self.tbbox.append(self.tbworkspace)
        self.tbbox.append(self.tbclass)
        self.tbbox.append(self.tbpid)
        self.tbbox.append(self.tbSIGKILL)
        # self.tbbox.append(self.tbsinkinput)
        # self.tbbox.append(self.tbcard)
        self.tbbox.append(self.tbvol)
        self.tbbox.append(self.tbcpusage)
        self.tbbox.append(self.tbmemusage)
        # self.tbbox.append(self.tbexe)
        self.tbbox.append(self.tbdiskusage)
        self.tbbox.append(self.todo_button)

        # self.tbSIGKILL.connect("clicked", self.sigkill_activewindow)
        self.top_panel_background.set_content(self.tbbox)
        

    def update_widget_with_timeout(self):
        GLib.timeout_add(1000, self.update_clock)
        GLib.timeout_add(200, self.update_widgets)
        GLib.timeout_add(200, self.update_title_topbar)
        GLib.timeout_add(10000, self.mullvad_status)
        GLib.timeout_add(600000, self.clean_pid_store)
          
    def show_panels(self):
        if self.all_panels_enabled:
            self.dock.do_start()
            self.top_panel.present()
            self.right_panel.present()
            self.top_panel_background.present()
                
    def setup_panel_buttons(self):
        if self.default_panel:
            workspace_buttons = self.utils.CreateFromAppList(self.workspace_list_config,
                "v",  "RightBar"
            )
            self.top_panel.set_content(self.top_panel_box_full)
            self.right_panel.set_content(workspace_buttons)

        if [i for i in self.args if "topbar" in i]:
            self.dockbar, workspace_buttons = self.create_widgets(
                "h", "TopBar"
            )
            self.all_panels_enabled = False
            self.top_panel.present()        
            
            
    def clock_dashboard(self, *_):
        #self.dashboard = Dashboard(application_id="org.hyprpanel.dashboard",flags= Gio.ApplicationFlags.FLAGS_NONE)
        #self.dashboard.run(sys.argv)
        self.utils.run_app("python {0}/calendar.py".format(self.scripts))
                
    def setup_gestures(self):
        # Setting up gestures for various UI components
        self.utils.CreateGesture(self.todo_button, 1, self.take_note_app)
        self.utils.CreateGesture(self.clock_box, 1, self.clock_dashboard)
        self.utils.CreateGesture(self.window_title, 1, self.manage_window_notes)
        self.utils.CreateGesture(self.tbclass, 1, self.dock.dockbar_append)
        self.utils.CreateGesture(self.tbclass, 3, self.dock.join_windows)
        self.utils.CreateGesture(self.tbSIGKILL, 1, self.sigkill_activewindow)
        self.utils.CreateGesture(self.tbvol, 1, self.toggle_mute_from_sink)
    
        # Gestures for left panel
        self.utils.CreateGesture(self.top_panel_box_left, 2, self.left_gesture_middle_click)
        self.utils.CreateGesture(self.top_panel_box_left, 3, self.left_gesture_right_click)
    
        # Gestures for center panel
        self.utils.CreateGesture(self.top_panel_box_center, 2, self.center_gesture_middle_click)
        self.utils.CreateGesture(self.top_panel_box_center, 3, self.center_gesture_right_click)
    
        # Gestures for right panel
        self.utils.CreateGesture(self.top_panel_box_right, 1, self.right_gesture_left_click)
        self.utils.CreateGesture(self.top_panel_box_right, 2, self.left_gesture_middle_click)
        self.utils.CreateGesture(self.top_panel_box_right, 3, self.left_gesture_right_click)
        
        #click will copy pid to clipboard
        self.tbpid_gesture = self.utils.CreateGesture(
            self.tbpid, 1, self.copy_to_clipboard
        )
    
        # Adding scroll event to the full panel
        EventScroll = Gtk.EventControllerScroll.new(Gtk.EventControllerScrollFlags.BOTH_AXES)
        EventScroll.connect("scroll", self.scroll_event)
        self.top_panel_box_full.add_controller(EventScroll)
    
    def close_fullscreen_buttons(self):
        # Creating close and full screen buttons for the top bar
        self.cf_box = Gtk.Box()
        self.fullscreen_button = self.utils.CreateButton("gtk-fullscreen", "hyprctl dispatch fullscreen", "cf_button", None)
        self.close_button = self.utils.CreateButton("close-symbolic", "hyprctl dispatch killactive", "cf_button", None)
        self.cf_box.append(self.fullscreen_button)
        self.cf_box.append(self.close_button)
        self.cf_box.add_css_class("cf_box")
        self.top_panel_box_for_buttons.append(self.cf_box)
        
    def right_position_launcher_topbar(self):
        # Creating close and full screen buttons for the top bar
        box = self.utils.CreateFromAppList(self.topbar_launcher_config,
                        "h", "TopBar"
        )
        self.top_panel_box_systray.append(box)
    
    def setup_clock_widget(self):
        # Configuring the clock widget for display
        self.clock_box.set_halign(Gtk.Align.CENTER)
        self.clock_box.set_hexpand(True)
        self.clock_box.set_baseline_position(Gtk.BaselinePosition.CENTER)
        self.clock_box.add_css_class("Clock")
    
        # Creating clock button with current date and time
        
        #self.clock_widget = self.utils.CreateButton("gnome-panel-clock-symbolic", "python {0}/calendar.py".format(self.scripts) , "ClockButton")
        self.clock_widget = Gtk.Label()
        #self.clock_widget = self.utils.CreateButton("gnome-panel-clock-symbolic", lambda: clock_dashboard() , "ClockButton")
        self.clock_widget.set_label(datetime.now().strftime("%d %A %H:%M"))
        self.clock_widget.set_halign(Gtk.Align.CENTER)
        self.clock_widget.set_hexpand(True)
        self.clock_box.append(self.clock_widget)
    
        # Adding the clock widget to the center panel
        self.top_panel_box_center.append(self.clock_box)
       
    def setup_panel_position(self):
        """
        Set up the position and content of various panels based on the command-line arguments.
    
        This method is responsible for configuring custom panel positions and widgets 
        based on the provided command-line arguments.
        """
    
        # Configuring the top panel based on command-line arguments
        if any("topbar" in i for i in self.args):
            self.dockbar, self.workspace_buttons = self.create_widgets("h", "TopBar")
            self.all_panels_enabled = False
            self.top_panel.present()
        if "--topbar-apps" in self.args:
            self.top_panel.set_content(self.dockbar)
        elif "--topbar-workspaces" in self.args:
            self.top_panel.set_content(self.workspace_buttons)
        elif "--topbar-todo" in self.args:
            self.top_panel.set_content(self.todo_label_box)
    
        # Configuring the right panel based on command-line arguments
        if any("rightbar" in i for i in self.args):
            self.dockbar, workspace_buttons = self.create_widgets("h", "RightBar")
            self.all_panels_enabled = False
            self.right_panel.present()
        elif "--rightbar-apps" in self.args:
            self.right_panel.set_content(self.dockbar)
        elif "--rightbar-workspaces" in self.args:
            self.right_panel.set_content(workspace_buttons)
        elif "--rightbar-todo" in self.args:
            self.right_panel.set_content(self.todo_label_box)
    
        # Configuring the left panel based on command-line arguments
        if any("leftbar" in i for i in self.args):
            CreatePanel(app, "LEFT", "BOTTOM", self.exclusive, 0, 32, "LeftBar")
            self.dockbar, workspace_buttons = self.create_widgets("v", "LeftBar")
            self.all_panels_enabled = False
            self.left_panel.present()
        elif "--leftbar-apps" in self.args:
            self.left_panel.set_content(self.dockbar)
        elif "--leftbar-workspaces" in self.args:
            self.left_panel.set_content(workspace_buttons)
        elif "--leftbar-todo" in self.args:
            self.left_panel.set_content(self.todo_label_box)
    
        # Configuring the bottom panel based on command-line arguments
        if any("bottombar" in i for i in self.args):
            self.dockbar, self.workspace_buttons = self.create_widgets("h", "BottomBar")
            self.all_panels_enabled = False
            self.bottom_panel.present()
        elif "--bottombar-apps" in self.args:
            self.bottom_panel.set_content(self.dockbar)
        elif "--bottombar-workspaces" in self.args:
            self.bottom_panel.set_content(self.workspace_buttons)
        elif "--bottombar-todo" in self.args:
            self.bottom_panel.set_content(self.todo_label_box)

            
    def load_css_from_file(self):
        css_provider = Gtk.CssProvider()
        css_provider.load_from_file(Gio.File.new_for_path(self.style_css_config))
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION,
        )
        
    def setup_panels(self):
        self.top_panel_box_left.add_css_class("top_panel_box_left")
        self.top_panel_box_right.add_css_class("top_panel_box_right")
        self.top_panel_box_systray.add_css_class("top_panel_box_systray")
        self.top_panel_box_center.add_css_class("top_panel_box_center")
        self.top_panel_box_full.add_css_class("top_panel_box_full")
        self.panel_on_top = "TOP"
        self.exclusive = True
        self.all_panels_enabled = True
        
        self.load_css_from_file()
        
        self.top_panel_box_right.set_halign(Gtk.Align.FILL)
        self.top_panel_box_right.set_homogeneous(True)
        self.top_panel_box_right.set_hexpand(True)
        
        # setup window title
        self.window_title = Adw.ButtonContent()
        self.top_panel_box_left.append(self.window_title)
        self.window_title.add_css_class("WindowTitle")
        
        self.menus = self.create_new_menu()
        self.setup_menus()

        if "--custom" in self.args:
            self.default_panel = False

        if "--background" in self.args:
            panel_on_top = "BOTTOM"
            self.exclusive = False
            
        self.default_panel = True
        with open(self.topbar_config, "r") as f:
            panel_toml = toml.load(f)
            for p in panel_toml:
                if "bottom" == p:
                    self.exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        self.exclusive = False

                    position = panel_toml[p]["position"]
                    self.bottom_panel = CreatePanel(
                        app, "BOTTOM", position, self.exclusive, 32, 0, "BottomBar"
                    )
                if "right" == p:
                    self.exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        self.exclusive = False
                    position = panel_toml[p]["position"]
                    self.right_panel = CreatePanel(
                        app, "RIGHT", position, self.exclusive, 0, 32, "RightBar"
                    )
                if "left" == p:
                    self.exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        self.exclusive = False
                    position = panel_toml[p]["position"]
                    self.left_panel = CreatePanel(
                        app, "LEFT", position, self.exclusive, 0, 32, "LeftBar"
                    )
                if "top" == p:
                    self.exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        self.exclusive = False
                    position = panel_toml[p]["position"]
                    self.top_panel = CreatePanel(
                        app,
                        "TOP",
                        position,
                        self.exclusive,
                        self.monitor_width,
                        24,
                        "TopBar",
                    )
                if "top_background" == p:
                    self.exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        self.exclusive = False
                    position = panel_toml[p]["position"]
                    self.top_panel_background = CreatePanel(
                        app,
                        "TOP",
                        position,
                        self.exclusive,
                        self.monitor_width,
                        18,
                        "TopBarBackground",
                    )
                    
    def create_menu_popover_bookmarks(self, app):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        self.menubutton_bookmarks = Gtk.Button()
        self.menubutton_bookmarks.connect("clicked", self.open_popover_bookmarks)
        self.menubutton_bookmarks.set_icon_name("bookmarks-organize-symbolic")
        self.top_panel_box_left.append(self.menubutton_bookmarks)
        
    def create_popover_bookmarks(self, *_):
        # Create a popover
        self.popover_bookmarks = Gtk.Popover.new()  # Create a new popover menu
        self.popover_bookmarks.set_autohide(True)
        show_searchbar_action =  Gio.SimpleAction.new("show_searchbar")
        show_searchbar_action.connect("activate",self.on_show_searchbar_action_actived)
        app.add_action(show_searchbar_action)
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window .set_min_content_width(200)
        self.scrolled_window .set_min_content_height(600)
        self.main_box = Gtk.Box.new( Gtk.Orientation.VERTICAL,0)
        self.searchbar = Gtk.SearchEntry.new()
        self.searchbar.grab_focus()
        self.searchbar.connect("search_changed",self.on_search_entry_changed)
        self.searchbar.set_focus_on_click(True)
        self.searchbar.props.hexpand = True
        self.searchbar.props.vexpand = True
        self.main_box.append(self.searchbar)
        self.listbox = Gtk.ListBox.new()
        self.listbox.connect('row-selected', lambda widget, row: self.open_url_from_bookmars((row)))
        self.searchbar.set_key_capture_widget(self.top_panel)
        self.listbox.props.hexpand = True
        self.listbox.props.vexpand = True
        self.listbox.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.listbox.set_show_separators(True)
        self.main_box.append(self.scrolled_window)
        self.scrolled_window.set_child(self.listbox)
        self.popover_bookmarks.set_child(self.main_box)
        bookmarks_path = os.path.join(self.home, ".bookmarks")
        with open(bookmarks_path, "r") as f:
            all_bookmarks = toml.load(f)
        for name in all_bookmarks:
            url = all_bookmarks[name]["url"]
            row_hbox  = Gtk.Box.new( Gtk.Orientation.HORIZONTAL,0)
            row_hbox.MYTEXT = url, all_bookmarks[name]["container"]
            icon = url + ".png"
            #just user -- instead of / so no conflicts with
            icon = icon.replace("/", "--")
            bookmark_image = os.path.join(self.config_path, "bookmarks/images/", icon)
            icon = bookmark_image
            self.listbox.append(row_hbox)
            line = Gtk.Label.new()
            line.add_css_class("label_from_bookmarks")
            line.set_label(name)
            line.props.margin_start = 5
            line.props.hexpand = True
            line.set_halign(Gtk.Align.START)
            image = Gtk.Image.new_from_file(icon)
            image.add_css_class("icon_from_popover_launcher")
            image.set_icon_size(Gtk.IconSize.LARGE)
            image.props.margin_end = 5
            image.set_halign(Gtk.Align.END)
            row_hbox.append(image)
            row_hbox.append(line)
        self.listbox.set_filter_func(self.on_filter_invalidate)
        # Create a menu button
        self.popover_bookmarks.set_parent(self.menubutton_bookmarks)
        self.popover_bookmarks.popup()
        return self.popover_bookmarks  
    
    
    
    
    
    def create_menu_popover_wallpaper(self, app):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        self.menubutton_wallpaper = Gtk.Button()
        self.menubutton_wallpaper.connect("clicked", self.open_popover_wallpaper)
        self.menubutton_wallpaper.set_icon_name("livewallpaper-indicator")
        self.top_panel_box_left.append(self.menubutton_wallpaper)
        
    def create_popover_wallpaper(self, *_):
        # Create a popover
        self.popover_wallpaper = Gtk.Popover.new()  # Create a new popover menu
        self.popover_wallpaper.set_autohide(True)
        show_searchbar_action =  Gio.SimpleAction.new("show_searchbar")
        show_searchbar_action.connect("activate",self.on_show_searchbar_action_actived)
        app.add_action(show_searchbar_action)
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window .set_min_content_width(400)
        self.scrolled_window .set_min_content_height(600)
        self.main_box = Gtk.Box.new(Gtk.Orientation.VERTICAL, 0)
        self.searchbar = Gtk.SearchEntry.new()
        self.searchbar.grab_focus()
        self.searchbar.connect("search_changed", self.on_search_entry_changed)
        self.searchbar.set_focus_on_click(True)
        self.searchbar.props.hexpand = True
        self.searchbar.props.vexpand = True
        self.main_box.append(self.searchbar)
        self.listbox = Gtk.ListBox.new()
        self.listbox.connect('row-selected', lambda widget, row: self.open_wallpaper((row)))
        self.searchbar.set_key_capture_widget(self.top_panel)
        self.listbox.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.main_box.append(self.scrolled_window)
        self.scrolled_window.set_child(self.listbox)
        self.popover_wallpaper.set_child(self.main_box)
        wallpapers_path = os.path.join(self.home, "Imagens/wallpapers")
        if not os.path.exists(wallpapers_path):
            os.mkdir(wallpapers_path)
        wallpaper_files = os.listdir(wallpapers_path)
        random.shuffle(wallpaper_files)
        for wallpaper in wallpaper_files:
            wallpaper = os.path.join(wallpapers_path, wallpaper)
            row_hbox = Gtk.Box.new(Gtk.Orientation.HORIZONTAL, 0)
            row_hbox.MYTEXT = wallpaper
            image = Gtk.Image.new_from_file(wallpaper)
            row_hbox.append(image)
            row_hbox.add_css_class("wallpaper")
            self.listbox.append(row_hbox)
        self.listbox.set_filter_func(self.on_filter_invalidate)
        # Create a menu button
        self.popover_wallpaper.set_parent(self.menubutton_wallpaper)
        self.popover_wallpaper.popup()
        return self.popover_wallpaper

    def create_menu_popover_launcher(self, app):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        self.menubutton_launcher = Gtk.Button()
        self.menubutton_launcher.connect("clicked", self.open_popover_launcher)
        self.menubutton_launcher.set_icon_name("archlinux-symbolic")
        self.top_panel_box_systray.append(self.menubutton_launcher)

    def create_popover_launcher(self, *_):
        # Create a popover
        self.popover_launcher = Gtk.Popover.new()  # Create a new popover menu
        show_searchbar_action =  Gio.SimpleAction.new("show_searchbar")
        show_searchbar_action.connect("activate",self.on_show_searchbar_action_actived)
        app.add_action(show_searchbar_action)
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window .set_min_content_width(400)
        self.scrolled_window .set_min_content_height(600)
        self.main_box = Gtk.Box.new( Gtk.Orientation.VERTICAL,0)
        self.searchbar = Gtk.SearchEntry.new()
        self.searchbar.grab_focus()
        self.searchbar.connect("search_changed",self.on_search_entry_changed)
        self.searchbar.set_focus_on_click(True)
        self.searchbar.props.hexpand = True
        self.searchbar.props.vexpand = True
 
        self.main_box.append(self.searchbar)
        self.listbox = Gtk.ListBox.new()
        self.listbox.connect('row-selected', lambda widget, row: self.run_app_from_launcher((row)))
        self.searchbar.set_key_capture_widget(self.top_panel)
        self.listbox.props.hexpand = True
        self.listbox.props.vexpand = True
        self.listbox.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.listbox.set_show_separators(True)
        self.main_box.append(self.scrolled_window)
        self.scrolled_window.set_child(self.listbox)
        self.popover_launcher.set_child(self.main_box)
        all_apps = Gio.AppInfo.get_all() 
        #randomize apps displayed every .popup()
        random.shuffle(all_apps)
        for i in all_apps:
            name = i.get_display_name()
            filename = i.get_id()
            icon = i.get_icon()
            if icon is None:
                continue
            row_hbox  = Gtk.Box.new( Gtk.Orientation.HORIZONTAL,0)
            row_hbox.MYTEXT = name, filename # to filter later
            self.listbox.append(row_hbox)
            line = Gtk.Label.new()
            line.add_css_class("label_from_popover_launcher")
            line.set_label(name)
            line.props.margin_start = 5
            line.props.hexpand = True
            line.set_halign(Gtk.Align.START)

            image = Gtk.Image.new_from_gicon(icon)
            image.add_css_class("icon_from_popover_launcher")
            image.set_icon_size(Gtk.IconSize.LARGE)
            image.props.margin_end = 5
            image.set_halign(Gtk.Align.END)
            row_hbox.append(image)
            row_hbox.append(line)
        self.listbox.set_filter_func(self.on_filter_invalidate)
        # Create a menu button
        self.popover_launcher.set_parent(self.menubutton_launcher)
        self.popover_launcher.popup()
        return self.popover_launcher

    def create_popover_menu_clipboard(self, app):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        self.menubutton_clipboard = Gtk.Button.new()
        self.menubutton_clipboard.connect("clicked", self.open_popover_clipboard)
        self.menubutton_clipboard.set_icon_name("edit-paste-symbolic")
        self.top_panel_box_systray.append(self.menubutton_clipboard)
        
    def create_popover_clipboard(self, *_):
        # Create a popover
        self.popover_clipboard = Gtk.Popover.new()  # Create a new popover menu
        show_searchbar_action =  Gio.SimpleAction.new("show_searchbar")
        show_searchbar_action.connect("activate",self.on_show_searchbar_action_actived)
        app.add_action(show_searchbar_action)
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window .set_min_content_width(600)
        self.scrolled_window .set_min_content_height(600)
        self.main_box = Gtk.Box.new( Gtk.Orientation.VERTICAL,0)
        self.searchbar = Gtk.SearchEntry.new()
        self.searchbar.grab_focus()
        self.searchbar.connect("search_changed",self.on_search_entry_changed)
        self.searchbar.set_focus_on_click(True)
        self.searchbar.props.hexpand = True
        self.searchbar.props.vexpand = True
 
        self.main_box.append(self.searchbar)
        self.listbox = Gtk.ListBox.new()
        self.listbox.connect('row-selected', lambda widget, row: self.wl_copy_clipboard(row))
        self.searchbar.set_key_capture_widget(self.top_panel)
        self.listbox.props.hexpand = True
        self.listbox.props.vexpand = True
        self.listbox.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.listbox.set_show_separators(True)
        self.main_box.append(self.scrolled_window)
        self.scrolled_window.set_child(self.listbox)
        self.popover_clipboard.set_child(self.main_box)
        #self.popover.connect("closed", self.popover_is_closed)
        clipboard_history = check_output("cliphist list".split()).decode().strip()
        clipboard_history = clipboard_history.split("\n")
        for i in clipboard_history:
            row_hbox  = Gtk.Box.new( Gtk.Orientation.HORIZONTAL,0)
            row_hbox.MYTEXT = i.split("\t")[1] # to filter later
            self.listbox.append(row_hbox)
            line = Gtk.Label.new()
            line.set_label(i)
            line.props.margin_start = 5
            line.props.hexpand = True
            line.set_halign(Gtk.Align.START)
            row_hbox.append(line)
            image = Gtk.Image.new_from_icon_name("gtk-copy")
            image.props.margin_end = 5
            image.set_halign(Gtk.Align.END)
            row_hbox.append(image)
        self.listbox.set_filter_func(self.on_filter_invalidate)
        # Create a menu button
        self.popover_clipboard.set_parent(self.menubutton_clipboard)
        self.popover_clipboard.popup()
        return self.popover_clipboard
        
    def wl_copy_clipboard(self, x):
        selected_text = x.get_child().MYTEXT
        echo = subprocess.Popen(('echo', selected_text), stdout=subprocess.PIPE)
        selected_text = subprocess.check_output(('cliphist', 'decode'), stdin=echo.stdout).decode()
        echo.wait()
        #not gonna use buggy pyperclip
        Popen(["wl-copy", selected_text])
        self.popover_clipboard.popdown()
        
    def open_url_from_bookmars(self, x):
        url, container = x.get_child().MYTEXT
        instance = Hyprland()
        all_windows = instance.get_windows()
        window = [i.address for i in all_windows if "firefoxdeveloperedition" in i.wm_class]
        if window:
            cmd = "hyprctl dispatch focuswindow address:{0}".format(window[0]).split()
            Popen(cmd)
        cmd = ["firefox-developer-edition", "ext+container:name={0}&url={1}".format(container, url)]
        Popen(cmd)
        self.popover_bookmarks.popdown()
        
    def open_wallpaper(self, x):
        cmd = "swww img {0}".format(x.get_child().MYTEXT).split()
        Popen(cmd)
        self.popover_wallpaper.popdown()
        


    def run_app_from_launcher(self, x):
        selected_text, filename = x.get_child().MYTEXT
        cmd = "gtk-launch {}".format(filename)
        self.utils.run_app(cmd)
        self.popover_launcher.popdown()
        
        
    def open_popover_bookmarks(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        if self.popover_bookmarks:
            if self.popover_bookmarks.is_visible():
                self.popover_bookmarks.popdown()
        self.create_popover_bookmarks(app)
        
    def open_popover_wallpaper(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        if self.popover_wallpaper:
            if self.popover_wallpaper.is_visible():
                self.popover_wallpaper.popdown()
        self.create_popover_wallpaper(app)
        
    def open_popover_launcher(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        if self.popover_launcher:
            if self.popover_launcher.is_visible():
                self.popover_launcher.popdown()
        self.create_popover_launcher(app)
        
    def open_popover_clipboard(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.ON_DEMAND)
        if self.popover_clipboard:
            if self.popover_clipboard.is_visible():
                self.popover_clipboard.popdown()
        self.create_popover_clipboard(app)
        

        
    def popover_is_closed(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.NONE)
        
    def popover_launcher_is_closed(self, *_):
        LayerShell.set_keyboard_mode(self.top_panel, LayerShell.KeyboardMode.NONE)
        
    def on_show_searchbar_action_actived(self,action,parameter):
        self.searchbar.set_search_mode(True) # Ctrl+F To Active show_searchbar and show searchbar
    
    def search_entry_grab_focus(self):
        self.searchentry.grab_focus()
        print("search entry is focused: {}".format(self.searchentry.is_focus()))
        
        
    def on_search_entry_changed(self,searchentry):
        """The filter_func will be called for each row after the call, 
        and it will continue to be called each time a row changes (via [method`Gtk`.ListBoxRow.changed]) 
        or when [method`Gtk`.ListBox.invalidate_filter] is called. """
        searchentry.grab_focus()
        self.listbox.invalidate_filter() # run filter (run self.on_filter_invalidate look at self.listbox.set_filter_func(self.on_filter_invalidate) )
        
    def on_filter_invalidate(self,row):
        text_to_search = self.searchbar.get_text().strip() # get text from searchentry and remove space from start and end
        if type(row) != str:
            row = row.get_child().MYTEXT[0]
        row = row.lower().strip()
        if text_to_search.lower() in row: # == row_hbox.MYTEXT (Gtk.ListBoxRow===>get_child()===>row_hbox.MYTEXT)
            return True # if True Show row
        return False 

    def mullvad_status(self):
        """
        Check the status of the Mullvad VPN and update the menu label accordingly.
    
        This function checks the status of the Mullvad VPN by executing the "mullvad status" command,
        and updates the label of the VPN menu item based on the status.
    
        Returns:
            bool: Always returns True.
        """
        # Execute the "mullvad status" command and decode the output
        output = check_output("mullvad status".split()).decode()
        
        # Update the menu label based on the output
        if "Disconnected" in output:
            vpn_menu = self.menus["VPN"]
            vpn_menu.set_label("VPN Disconnected")
        elif "Connected" in output:
            vpn_menu = self.menus["VPN"]
            vpn_menu.set_label("VPN")
        
        return True
    
    def take_note_app(self, *_):
        """
        Open the note-taking application specified in the configuration file.
    
        This function reads the configuration file to retrieve the command for the note-taking application,
        and then executes the command to open the application.
    
        Args:
            *_: Additional arguments (unused).
    
        Returns:
            None
        """
        # Read the configuration file and load the configuration
        with open(self.topbar_config, "r") as f:
            config = toml.load(f)
        
        # Run the note-taking application using the specified command
        self.utils.run_app(config["take_note_app"]["cmd"])
    
    def HyprlandInstance(self):
        """
        Create and return an instance of the Hyprland class.
    
        Returns:
            Hyprland: An instance of the Hyprland class.
        """
        return Hyprland()
    
    def get_hyprland_active_window(self):
        instance = Hyprland()
        active_window = instance.get_active_window()
        return active_window
    
    def get_monitor_info(self):
        """
        Retrieve information about the connected monitors.
    
        This function retrieves information about the connected monitors, such as their dimensions and names,
        and returns the information as a dictionary.
    
        Returns:
            dict: A dictionary containing information about the connected monitors.
        """
        # Get the default display and retrieve information about the connected monitors
        screen = Gdk.Display.get_default()
        monitors = screen.get_monitors()
        monitor_info = {}
        for monitor in monitors:
            monitor_width = monitor.get_geometry().width
            monitor_height = monitor.get_geometry().height
            name = monitor.props.connector
            monitor_info[name] = [monitor_width, monitor_height]
        
        return monitor_info
    
    def HyprInfo(self):
        """
        Retrieve information about the active window.
    
        This function retrieves information about the active window, such as its window class and address,
        and returns the information as a dictionary.
    
        Returns:
            dict: A dictionary containing information about the active window.
        """
        info = {}
        info["window_class"] = self.instance.get_active_window().initial_wm_class
        info["address"] = self.instance.get_active_window().address
        return info

    
    def create_widgets(self, orientation, class_style):
        """
        Create widgets based on the specified orientation and class style.
    
        This function creates widgets, such as a dockbar and workspace buttons, based on the specified
        orientation and class style, and returns the created widgets.
    
        Args:
            orientation (str): The orientation of the widgets (e.g., "horizontal", "vertical").
            class_style (str): The class style of the widgets.
    
        Returns:
            tuple: A tuple containing the created dockbar and workspace buttons.
        """
        dockbar = self.utils.CreateFromAppList(self.dockbar_config,
            orientation,  class_style
        )
        workspace_buttons = self.utils.CreateFromAppList(self.workspace_list_config,
            orientation,  class_style
        )
        return dockbar, workspace_buttons
    
    def todo_txt(self):
        """
        Update the label of the TODO button with the last line from the TODO.txt file.
    
        This function reads the last line from the TODO.txt file and updates the label of the TODO button
        with the content of the last line.
    
        Returns:
            bool: Always returns True.
        """
        # Define the path to the TODO.txt file
        todo_filepath = os.path.join(self.home, "Documentos", "todo.txt")
        
        # Read the last line from the TODO.txt file
        last_line = open(todo_filepath, "r").readlines()[-1]
        
        # Update the label of the TODO button with the content of the last line
        self.todo_button.set_label(last_line.strip())
        
        return True
    

            
    def on_button_press_event(self, widget, event):
        """
        Handle the button press event.
    
        This function handles the button press event by checking the type of the event and the button
        that was pressed, and then performing the corresponding action.
    
        Args:
            widget: The widget that emitted the event.
            event: The event object containing information about the event.
    
        Returns:
            None
        """
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            return True
    
    def right_side_middle_click(self, gesture, data, x, y):
        """
        Handle the middle click gesture on the right side.
    
        This function handles the middle click gesture on the right side by executing the "kitty" command
        to open the Kitty terminal emulator.
    
        Args:
            gesture: The gesture object.
            data: Additional data (unused).
            x: The x-coordinate of the click.
            y: The y-coordinate of the click.
    
        Returns:
            None
        """
        Popen("kitty".split())
    
    def scroll_event(self, controller, _dx, dy):
        """
        Handle the scroll event.
    
        This function handles the scroll event by checking the direction of the scroll and adjusting
        the volume accordingly using the "pactl" command.
    
        Args:
            controller: The controller object.
            _dx: The horizontal delta (unused).
            dy: The vertical delta representing the direction and speed of the scroll.
    
        Returns:
            None
        """
        # Check the direction of the scroll and adjust the volume using the "pactl" command
        if dy > 0:
            self.utils.run_app("pactl -- set-sink-volume 0 -8%")
        else:
            self.utils.run_app("pactl -- set-sink-volume 0 +8%")

    def left_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def left_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def left_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["center_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["center_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def create_simple_action(self):
        """
        Create a simple action to run a command.
    
        This function creates a simple action named "run-command" that takes a string parameter.
        It connects the "activate" signal of the action to the menu_run_action method.
    
        Args:
            None
    
        Returns:
            None
        """
        # Create a simple action with the specified name and parameter type
        action = Gio.SimpleAction(name="run-command", parameter_type=GLib.VariantType("s"))
        
        # Connect the "activate" signal of the action to the menu_run_action method
        action.connect("activate", self.menu_run_action)
        
        # Add the action to the application
        app.add_action(action)
    
    def create_menu_item(self, menu, name, cmd):
        """
        Create a menu item with the specified name and command.
    
        This function creates a menu item with the specified name and command,
        sets its action to "app.run-command" with the command as the target value,
        and appends the menu item to the specified menu.
    
        Args:
            menu (Gio.Menu): The menu to which the menu item should be appended.
            name (str): The name of the menu item.
            cmd (str): The command associated with the menu item.
    
        Returns:
            None
        """
        # Create a new menu item with the specified name
        menuitem = Gio.MenuItem.new(name, None)
        
        # Set the action of the menu item to "app.run-command" with the command as the target value
        menuitem.set_action_and_target_value("app.run-command", GLib.Variant("s", cmd))
        #menuitem.set_icon("audio-card-symbolic")
        
        # Append the menu item to the specified menu
        menu.append_item(menuitem)
    
    def create_new_menu(self):
        """
        Create a new menu based on the configuration file.
    
        This function reads the menu configuration from a TOML file,
        creates a new menu based on the configuration, and returns a dictionary
        containing the menu buttons associated with the created menus.
    
        Args:
            None
    
        Returns:
            dict: A dictionary containing the menu buttons associated with the created menus.
        """
        # Read the menu configuration from the specified file
        with open(self.menu_config, "r") as f:
            menu_toml = toml.load(f)
        
        # Initialize a dictionary to store the menu buttons
        menu_buttons = {}
        
        # Iterate through the menu configuration and create the corresponding menus and menu items
        for m in menu_toml:
            if m == "icons":
                continue
            menu = Gio.Menu()
            btn = Gtk.MenuButton(label=m)
            #if no icon is specified in [icons] from menu.toml then use Label instead
            try:
                btn.set_icon_name(menu_toml["icons"][m])
            except:
                btn.set_label(label=m)
                
            btn.set_menu_model(menu)
            submenu = None
            dsubmenu = {}
            menu_buttons[m] = btn
            self.create_simple_action()
            for item in menu_toml[m].values():
                name = item[0]["name"]
                cmd = item[0]["cmd"]
                if "submenu" in item[0]:
                    submenu_label = item[0]["submenu"]
                    submenu = dsubmenu.get(submenu_label)
                    if submenu is None:
                        submenu = Gio.Menu()
                        dsubmenu[submenu_label] = submenu
                    self.create_menu_item(submenu, name, cmd)
                else:
                    self.create_menu_item(menu, name, cmd)
            if dsubmenu:
                [menu.append_submenu(k, dsubmenu[k]) for k in dsubmenu.keys()]
        
        # Return the dictionary containing the menu buttons
        return menu_buttons

    def sigkill_activewindow(self, *_):
        pid = self.instance.get_active_window().pid
        cmd = "kill -9 {0}".format(pid)
        self.utils.run_app(cmd)

    def menu_run_action(self, action, param):
        self.utils.run_app(param.get_string())

    def update_clock(self):
        self.clock_widget.set_label(datetime.now().strftime("%d %A %H:%M"))
        return True

    def load_topbar_config(self):
        with open(self.topbar_config, "r") as f:
            return toml.load(f)

    def clean_pid_store(self):
        # [optimization]
        # every 10 minutes check for non-existent pids and clean the dict
        for pid in self.psutil_store.keys():
            if pid not in self.pid_list:
                del self.psutil_store[pid]

    def copy_to_clipboard(self, *_):
        # lazy to not use wl-copy
        self.utils.run_app("wl-copy {0}".format(self.instance.get_active_window().pid))

    def sink_input_info(self):
        pactl = "pactl list sink-inputs".split()
        sink_inputs = check_output(pactl).decode()
        sinklist = sink_inputs.split("Sink Input #")
        info = {}
        info["sinklist"] = sinklist
        return info

    def toggle_mute_from_sink(self, *_):
        pid = self.instance.get_active_window().pid
        info = self.sink_input_info()
        sinklist = info["sinklist"]
        for sink in sinklist:
            if 'application.process.id = "{0}"'.format(pid) in sink:
                sink = sink.split("\n")[0]
                self.utils.run_app("pactl set-sink-input-mute {0} toggle".format(sink))

    def notify_client(self, *_):
        self.utils.run_app("swaync-client -t")

    def disk_usage_by_pid(self):
        pid = self.instance.get_active_window().pid
        p = psutil.Process(pid)
        io_counters = p.io_counters()
        disk_usage_process = io_counters[2] + io_counters[3]  # read_bytes + write_bytes
        return int(round(disk_usage_process / (1024**2), 2))

    def manage_window_notes(self, *_):
        """
        Manage notes for the active window.
    
        This function retrieves information about the active window, such as its initial title
        and window class, and updates a configuration file with this information. It also
        manages the creation and opening of a Markdown file for notes related to the window.
    
        Args:
            *_: Additional arguments (unused).
    
        Returns:
            None
        """
        # Retrieve information about the active window
        active_window = self.instance.get_active_window()
        initial_title = active_window.initial_title.lower()
        wm_class = active_window.initial_wm_class.lower()
        title = active_window.title.lower()
    
        # Adjust the window class based on specific conditions
        if "firefox" in wm_class and "." in title:
            wm_class = title.split()[0]
        if initial_title == "zsh":
            wm_class = title.split()[0]
    
        # Load existing window notes from the configuration file
        with open(self.window_notes_config, "r") as config_file:
            existing_notes = toml.load(config_file)
    
        # Create a new entry for the active window and update the configuration
        new_entry = {wm_class: {"initial_title": initial_title, "title": title}}
        updated_notes = ChainMap(new_entry, existing_notes)
    
        # Save the updated notes back to the configuration file
        with open(self.window_notes_config, "w") as config_file:
            toml.dump(updated_notes, config_file)
    
        # Define the path and command for the Markdown file related to the window
        filepath = f"/home/neo/Notes/{wm_class}.md"
        cmd = f"marktext {filepath}"
    
        # Create the Markdown file if it doesn't exist
        if not os.path.isfile(filepath):
            Path(filepath).touch()
    
        # run the Markdown editor application
        self.utils.run_app(cmd)


    def output_loop(self, output, label):
        """
        Update the label with the output of a command.
    
        This function executes the specified command, captures its output, and updates
        the label widget with the captured output.
    
        Args:
            output (str): The command whose output will be displayed in the label.
            label (Gtk.Label): The label widget to update with the command output.
    
        Returns:
            bool: True if the label content is successfully updated, False otherwise.
        """\
        # Execute the specified command and capture its output
        command_output = check_output(output.split()).decode().replace("\n", "")
        
        # Set the label content with the captured output using markup
        separator = " "
        label.set_markup(command_output + separator)
        
        # Remove the previously scheduled source for single execution
        GLib.Source.remove(self.exec_once)
        
        # Return True to indicate successful update
        return True
    
    def create_cmd_label(self, output, position, css_class, refresh):
        """
        Create and configure a label widget to display command output.
    
        This function creates a label widget with the specified CSS class and adds it to a box container 
        based on the specified position. It also schedules periodic updates of the label content.
    
        Args:
            output (str): The command whose output will be displayed in the label.
            position (str): The position where the label should be added ('left', 'right', or 'center').
            css_class (str): The CSS class to apply to the label and the box container.
            refresh (int): The interval in milliseconds for refreshing the label content.
    
        Returns:
            None
        """
        # Create a new label widget
        label = Gtk.Label()
        
        # Create a new box container
        box = Gtk.Box()
        
        # Configure the box container properties
        box.set_halign(Gtk.Align.END)
        box.set_hexpand(False)
        box.set_baseline_position(Gtk.BaselinePosition.BOTTOM)
        
        # Add the specified CSS class to the box container and the label
        box.add_css_class(css_class)
        label.add_css_class(css_class)
        
        # Add the label to the box container
        box.append(label)
        
        # Determine the position to add the box container and label
        if position == "left":
            self.top_panel_box_left.append(box)
        elif position == "right":
            self.top_panel_box_systray.append(box)
        elif position == "center":
            self.clock_box.append(box)
        
        # Schedule the periodic updates of the label content
        self.exec_once = GLib.timeout_add(1000, lambda: self.output_loop(output, label))
        GLib.timeout_add(refresh, lambda: self.output_loop(output, label))
    
    def cmd_output(self):
        """
        Read command settings from a configuration file and create corresponding command labels.
    
        This function reads command settings from a TOML configuration file, iterates through each setting,
        and creates and configures the corresponding command label using the create_cmd_label function.
    
        Args:
            None
    
        Returns:
            None
        """
        # Read command settings from the configuration file
        with open(self.cmd_config, "r") as config_file:
            cmd_settings = toml.load(config_file)
        
        # Iterate through each command setting and create/configure the corresponding command label
        for label_key in cmd_settings:
            output = cmd_settings[label_key]["cmd"]
            position = cmd_settings[label_key]["position"]
            refresh = cmd_settings[label_key]["refresh"]
            css_class = cmd_settings[label_key]["css_class"]
            
            # Create and configure the command label with the specified settings
            self.create_cmd_label(output, position, css_class, refresh)


                                              
    def volume_watch(self):
        """
        Watch for changes in the volume and update the volume and card labels accordingly.
    
        This function uses the `pulsectl` library to monitor the volume and updates the labels
        with the current volume percentage and the description of the active audio sink.
    
        """
        # Initialize PulseAudio client
        with pulsectl.Pulse("volume-increaser") as pulse:
            
            # Iterate through all the audio sinks
            for sink in pulse.sink_list():
                
                # Check if the sink is currently running (active)
                if "running" in str(sink.state):
                    
                    # Calculate the volume percentage and round it to the nearest whole number
                    volume = round(sink.volume.values[0] * 100)
                    
                    # Update the volume label with the current volume percentage
                    self.tbvol.set_label("Volume: {0}%".format(volume))
                    
                    # Update the card label with the description of the active audio sink
                    self.tbcard.set_label("{0}".format(sink.description))
    
                        
    def update_title_topbar(self):
        """
        Update the title bar based on the currently active window.
    
        Returns:
            bool: True if the update was successful, False otherwise.
        """

        aw = self.get_hyprland_active_window()
        title, wclass, initial_title = aw.title, aw.wm_class, aw.initial_title
        title = self.modify_title(title)
        self.window_title.set_label(title)
            
        # Skip update if the active window hasn't changed or if in the "OVERVIEW" workspace
        if self.active_window_changed != aw.address:
            self.active_window_changed = aw.address
        else:
            return True
        if self.instance.get_workspace_by_name("OVERVIEW"):
            return True
        
        # Apply custom icon if available
        wclass = self.apply_custom_icon(wclass)
        
        # Modify title based on certain patterns
        title = self.modify_title(title)
        
        # Update title and icon
        self.update_title_and_icons(title, wclass, initial_title)
                    
        return True
    
    
    def has_active_window_changed(self):
        active_window = self.get_hyprland_active_window()
        address = active_window.address
        #check if panel started now then allow to update widgets
        #if not, when you start the panel, the title from active window won't update
        #until you move the focus for another window
        #thus, checking once and returning True
        if self.active_window_changed is None:
            if self.hyprpanel_started_now == True:
                self.active_window_changed = address
                self.hyprpanel_started_now = False
                return True
            
        if self.active_window_changed != address:
            self.active_window_changed = address
            return True
        else:
            return False
        
            
    def update_widgets(self):
        """
        Update widgets based on the currently active window.
    
        Returns:
            bool: True if the update was successful, False otherwise.
        """
        
        # Skip update if in fullscreen or in the "OVERVIEW" workspace
        if not self.instance.get_workspace_by_name("OVERVIEW"):
            return True
        
        
        window_changed = self.has_active_window_changed()
                
        # Extract window information
        active_window = self.instance.get_active_window()
        title, workspace_id, pid, wclass, initial_title = self.extract_widget_info(active_window)
        
        # Apply custom icon if available
        wclass = self.apply_custom_icon(wclass)
        
        # Fetch and format process information
        mem_usage, exe, cpu_usage = self.fetch_process_info(pid)
        
        # Modify title based on certain patterns
        title = self.modify_title(title)
        
        # Update widget labels and icons
        self.update_widget_labels(workspace_id, pid, wclass, cpu_usage, mem_usage, exe, window_changed)
        
        # Update title and icon
        if window_changed:
            self.update_title_and_icons(title, wclass, initial_title)
           
        return True
    

    def extract_widget_info(self, active_window):
        """Extract and return widget-related information."""
        title = active_window.title[0:100]
        workspace_id = active_window.workspace_id
        pid = active_window.pid
        wclass = active_window.initial_wm_class.lower()
        initial_title = active_window.initial_title
        return title, workspace_id, pid, wclass, initial_title
    
    def apply_custom_icon(self, wclass):
        """Apply custom icon if available."""
        try:
            return self.panel_cfg["change_icon_title"][wclass]
        except Exception as e:
            pass
        return wclass
    
    def fetch_process_info(self, pid):
        """Fetch and return process information."""
        if pid not in self.psutil_store.keys():
            process = psutil.Process(pid)
            self.psutil_store[pid] = process
        mem_usage = self.utils.convert_size(int(self.psutil_store[pid].memory_info().rss))
        exe = self.psutil_store[pid].exe()
        cpu_usage = int(self.psutil_store[pid].cpu_percent())
        return mem_usage, exe, cpu_usage
    
    def modify_title(self, title):
        """Modify title based on certain patterns."""
        if "www." in title:
            title = title.split("www.")[1]           
        if "  " in title:
            title = title.split("  ")[0]
        return title
    
    def icon_exist(self, argument):
        exist = [i for i in self.icon_theme_list if argument in i]
        return exist
    
    def update_title_and_icons(self, title, wclass, initial_title):
        """Update title and icons."""
        icon_exist = self.icon_exist(wclass)
        
        if icon_exist:
            self.window_title.set_icon_name(wclass)
        else:
            desktop = self.utils.search_local_desktop(initial_title)
            icon = desktop.split(".desktop")[0]
            if desktop:
                self.window_title.set_icon_name(icon)
            
        self.tbclass.set_icon_name(wclass)
        self.window_title.set_label(title)

        if initial_title == "zsh":
            label = title.split(" ")[0]
            icon_exist = self.icon_exist(label)
            if icon_exist:
                self.window_title.set_icon_name(label)
                self.tbclass.set_icon_name("{0}".format(label))

    
    def update_widget_labels(self, workspace_id, pid, wclass, cpu_usage, mem_usage, exe, window_changed):
        """Update widget labels."""
        if window_changed:
            self.tbpid.set_label("PID: {0}".format(pid))
            self.tbclass.set_label("{0}".format(wclass))
            self.tbexe.set_label("Exe: {0}".format(exe))
            self.tbdiskusage.set_label("Disk: {0}MB".format(self.disk_usage_by_pid()))
        self.tbworkspace.set_label("W: {0}".format(workspace_id))
        self.tbcpusage.set_label("CPU: {0}%".format(cpu_usage))
        self.tbmemusage.set_label("MEM: {0}".format(mem_usage))
        self.volume_watch()
    
app = Panel(application_id="com.hyprpanel.GtkApplication")
app.run(None)
    

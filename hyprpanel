#!/usr/bin/env python3
import os
from pathlib import Path

os.environ["GI_TYPELIB_PATH"] = "/usr/include/hyprpanel/src"

from ctypes import CDLL

CDLL("libgtk4-layer-shell.so")
from subprocess import Popen
from subprocess import check_output, call
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from src.core.create_panel import *
import asyncio
from gi.repository import Gtk, Adw, GLib, Gio, Gdk
from datetime import datetime
import json
import sys
import importlib

spam_loader = importlib.util.find_spec("hyprpy")
found = spam_loader is not None

if not found:
    print("Module hyprpy not found, try | pip install hyprpy | and try again")
    sys.exit()

from hyprpy import Hyprland
from multiprocessing import Process
from hyprpy.utils.signals import Signal
import psutil
import math
import pulsectl
import toml
from collections import ChainMap
from src.plugins.dockbar import Dockbar
from src.core.utils import Utils


class Panel(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.utils = Utils(
            application_id="com.github.utils",
        )
        self.connect("activate", self.on_activate)
        self.bottom_panel = None
        self.right_panel = None
        self.left_panel = None
        self.top_panel = None
        self.top_panel_background = None
        self.top_panel_box_left = Gtk.Box(spacing=10)
        self.top_panel_box_systray = Gtk.Box(spacing=0)
        self.top_panel_box_right = Gtk.Box(spacing=6)
        self.top_panel_grid_right = Gtk.Grid()
        self.top_panel_grid_right.attach(self.top_panel_box_right, 1, 0, 1, 2)
        self.top_panel_grid_right.attach_next_to(
            self.top_panel_box_systray,
            self.top_panel_box_right,
            Gtk.PositionType.RIGHT,
            1,
            2,
        )
        self.top_panel_box_center = Gtk.Box(spacing=6)
        self.top_panel_box_full = Gtk.Grid()
        self.top_panel_box_full.set_column_homogeneous(True)
        self.top_panel_box_full.attach(self.top_panel_box_left, 1, 0, 1, 2)
        self.top_panel_box_full.attach_next_to(
            self.top_panel_box_center,
            self.top_panel_box_left,
            Gtk.PositionType.RIGHT,
            1,
            2,
        )
        self.top_panel_box_full.attach_next_to(
            self.top_panel_grid_right,
            self.top_panel_box_center,
            Gtk.PositionType.RIGHT,
            1,
            3,
        )
        self.monitor_width = 0
        self.monitor_height = 0
        self.toggle_mute = {}
        self.volume = 0
        self.clock_box = Gtk.Box()
        self.args = sys.argv
        self.home = os.path.expanduser("~")
        self.config_path = os.path.join(self.home, ".config/hyprpanel")
        self.dockbar_config = os.path.join(self.config_path, "dockbar.toml")
        self.style_css_config = os.path.join(self.config_path, "style.css")
        self.workspace_list_config = os.path.join(self.config_path, "workspacebar.toml")
        self.topbar_config = os.path.join(self.config_path, "panel.toml")
        self.menu_config = os.path.join(self.config_path, "menu.toml")
        self.window_notes_config = os.path.join(self.config_path, "window-config.toml")
        self.cmd_config = os.path.join(self.config_path, "cmd.toml")
        self.psutil_store = {}
        self.panel_cfg = self.load_topbar_config()
        self.dock = Dockbar(
            application_id="com.github.dockbar",
        )
        self.icon_theme_list = Gtk.IconTheme().get_icon_names()

    def on_activate(self, app):
        self.top_panel_box_left.add_css_class("top_panel_box_left")
        self.top_panel_box_right.add_css_class("top_panel_box_right")
        self.top_panel_box_systray.add_css_class("top_panel_box_systray")
        self.top_panel_box_center.add_css_class("top_panel_box_center")
        self.top_panel_box_full.add_css_class("top_panel_box_full")
        panel_on_top = "TOP"
        exclusive = True
        all_panels_enabled = True
        self.instance = self.HyprlandInstance()
        default_panel = True

        # start cmd output session, cmd.toml
        self.cmd_output()

        # get monitor info and set the width, height for the panel
        monitor_info = self.get_monitor_info()
        for monitor_name in monitor_info:
            if self.instance.get_monitor_by_name(name=monitor_name).is_focused:
                self.monitor_width, self.monitor_height = monitor_info[monitor_name]

        if "--custom" in self.args:
            default_panel = False

        if "--background" in self.args:
            panel_on_top = "BOTTOM"
            exclusive = False

        # panel.cfg setup
        with open(self.topbar_config, "r") as f:
            panel_toml = toml.load(f)
            for p in panel_toml:
                if "bottom" == p:
                    exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        exclusive = False

                    position = panel_toml[p]["position"]
                    self.bottom_panel = CreatePanel(
                        app, "BOTTOM", position, exclusive, 32, 0, "BottomBar"
                    )
                if "right" == p:
                    exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        exclusive = False
                    position = panel_toml[p]["position"]
                    self.right_panel = CreatePanel(
                        app, "RIGHT", position, exclusive, 0, 32, "RightBar"
                    )
                if "left" == p:
                    exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        exclusive = False
                    position = panel_toml[p]["position"]
                    self.left_panel = CreatePanel(
                        app, "LEFT", position, exclusive, 0, 32, "LeftBar"
                    )
                if "top" == p:
                    exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        exclusive = False
                    position = panel_toml[p]["position"]
                    self.top_panel = CreatePanel(
                        app,
                        "TOP",
                        position,
                        exclusive,
                        self.monitor_width,
                        24,
                        "TopBar",
                    )
                if "top_background" == p:
                    exclusive = True
                    if panel_toml[p]["Exclusive"] == "False":
                        exclusive = False
                    position = panel_toml[p]["position"]
                    self.top_panel_background = CreatePanel(
                        app,
                        "TOP",
                        position,
                        exclusive,
                        self.monitor_width,
                        18,
                        "TopBarBackground",
                    )

        # load css
        css_provider = Gtk.CssProvider()
        css_provider.load_from_file(Gio.File.new_for_path(self.style_css_config))
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION,
        )

        # clock widget
        self.clock_box.set_halign(Gtk.Align.CENTER)
        self.clock_box.set_hexpand(True)
        self.clock_box.set_baseline_position(Gtk.BaselinePosition.CENTER)
        self.clock_box.add_css_class("Clock")
        self.clock_button = self.utils.CreateButton(
            "gnome-panel-clock-symbolic", "cal", "ClockButton"
        )
        self.clock_button.set_label(datetime.now().strftime("%d %A %H:%M"))
        self.clock_button.set_halign(Gtk.Align.CENTER)
        self.clock_button.set_hexpand(True)
        self.clock_box.append(self.clock_button)

        # clock widget
        self.clock_box1 = Gtk.Box()
        self.clock_box1.set_halign(Gtk.Align.CENTER)
        self.clock_box1.set_hexpand(True)

        # self.clock_button1 = Gtk.Button()
        # self.clock_box1.append(self.clock_button1)
        # self.clock_box.append(self.clock_box1)
        # ww = Gtk.Dialog()
        # self.popover = Gtk.Popover()
        # self.popover.set_parent(ww)
        # self.utils.CreateGesture(self.clock_button1, 1, self.myapprun)

        # close and full screen buttons at the topbar
        self.cf_box = Gtk.Box()
        self.close_button = self.utils.CreateButton(
            "close-symbolic", "hyprctl dispatch killactive", "cf_button"
        )
        self.fullscreen_button = self.utils.CreateButton(
            "gtk-fullscreen", "hyprctl dispatch fullscreen", "cf_button"
        )
        self.cf_box.append(self.close_button)
        self.cf_box.append(self.fullscreen_button)
        self.cf_box.add_css_class("cf_box")
        self.top_panel_box_left.append(self.cf_box)

        GLib.timeout_add(1000, self.update_clock)
        GLib.timeout_add(200, self.update_widgets)
        GLib.timeout_add(10000, self.mullvad_status)
        GLib.timeout_add(600000, self.clean_pid_store)

        # volumebutton = Gtk.VolumeButton.new()
        # volumebutton.connect("value-changed",self.on_volume_value_changed)
        # volbox.append(volumebutton)

        # notes label
        self.todo_button = Adw.ButtonContent()
        self.todo_button.add_css_class("todo_label")
        self.todo_button.set_icon_name("todoist-symbolic")
        todo = os.path.join(self.home, "Documentos", "todo.txt")

        try:
            txt = open(todo, "r").readlines()[-1]
            self.todo_button.set_label(txt.strip())
            GLib.timeout_add(600000, self.todo_txt)
        except IndexError:
            print("todo.txt is empity or does not exist")

        self.top_panel_box_right.set_halign(Gtk.Align.FILL)
        self.top_panel_box_right.set_homogeneous(True)
        self.top_panel_box_right.set_hexpand(True)
        self.menus = self.NewMenu()
        # create menus
        for menu in self.menus.values():
            self.top_panel_box_systray.append(menu)
            menu.add_css_class("systray")
            self.top_panel_box_systray.set_halign(Gtk.Align.END)
            self.top_panel_box_systray.set_hexpand(True)

        # gesture space for clicks
        self.top_panel_box_center.append(self.clock_box)

        self.iconbox = Gtk.Box(spacing=0)
        self.icon_title = self.utils.CreateButton("kitty", "nwg-drawer", "kitty")
        self.iconbox.append(self.icon_title)
        # self.top_panel_box_left.append(self.iconbox)

        # setup window title
        self.window_title = Adw.ButtonContent()
        self.top_panel_box_left.append(self.window_title)

        self.window_title.add_css_class("WindowTitle")

        # setup label for top bar background
        self.tbbox = Gtk.Box(spacing=20)
        self.tblabelspace = Gtk.Label(label="    ")
        self.tbworkspace = self.utils.btn_background(
            "tbworkspace", "workspace-symbolic"
        )
        self.tbpid = self.utils.btn_background("tbpid", "view-process-tree")
        self.tbpid_gesture = self.utils.CreateGesture(
            self.tbpid, 1, self.copy_to_clipboard
        )
        self.tbclass = self.utils.btn_background("tbclass", "cs-windows-symbolic")
        self.tbcpusage = self.utils.btn_background(
            "tbcpusage", "cpu-frequency-indicator"
        )
        self.tbmemusage = self.utils.btn_background(
            "tbmemusage", "indicator-sensors-memory"
        )
        self.tbsinkinput = self.utils.btn_background(
            "tbsinkinput", "multimedia-volume-control-symbolic"
        )
        self.tbSIGKILL = self.utils.btn_background("tbSIGKILL", "window-close-symbolic")
        self.tbdiskusage = self.utils.btn_background(
            "tbdiskusage", "disk-check-symbolic"
        )
        self.tbvol = self.utils.btn_background(
            "tbvol", "multimedia-volume-control-symbolic"
        )
        self.tbcard = self.utils.btn_background("tbvoltbcard", "audio-card")
        self.tbdiskusage.set_label("Disk Usage")
        self.tbsinkinput.set_label("Toggle Mute")
        self.tbvol.set_label("Volume")
        self.tbSIGKILL.set_label("SIGKILL")
        self.tbexe = self.utils.btn_background("tbexe", "exec")
        self.tbbox.append(self.tblabelspace)
        self.tbbox.append(self.tbworkspace)
        self.tbbox.append(self.tbclass)
        self.tbbox.append(self.tbpid)
        self.tbbox.append(self.tbSIGKILL)
        # self.tbbox.append(self.tbsinkinput)
        # self.tbbox.append(self.tbcard)
        self.tbbox.append(self.tbvol)
        self.tbbox.append(self.tbcpusage)
        self.tbbox.append(self.tbmemusage)
        # self.tbbox.append(self.tbexe)
        self.tbbox.append(self.tbdiskusage)
        self.tbbox.append(self.todo_button)

        # self.tbSIGKILL.connect("clicked", self.sigkill_activewindow)
        self.top_panel_background.set_content(self.tbbox)

        EventScroll = Gtk.EventControllerScroll.new(
            Gtk.EventControllerScrollFlags.BOTH_AXES
        )
        EventScroll.connect("scroll", self.scroll_event)
        self.top_panel_box_full.add_controller(EventScroll)

        # create panel buttons
        if default_panel:
            workspace_buttons = self.utils.CreateFromAppList(
                "vertical", self.workspace_list_config, "RightBar"
            )
            self.top_panel.set_content(self.top_panel_box_full)
            self.right_panel.set_content(workspace_buttons)

        if [i for i in self.args if "topbar" in i]:
            self.dockbar_config, workspace_buttons = self.create_widgets(
                "horizontal", "TopBar"
            )
            all_panels_enabled = False
            self.top_panel.present()

        # this whole section is intended to setup custom panel positions and widgets
        if "--topbar-apps" in self.args:
            self.top_panel.set_content(self.dockbar_config)
        if "--topbar-workspaces" in self.args:
            self.top_panel.set_content(workspace_buttons)
        if "--topbar-todo" in self.args:
            self.top_panel.set_content(self.todo_label_box)

        if [i for i in self.args if "rightbar" in i]:
            self.dockbar_config, workspace_buttons = self.create_widgets(
                "vertical", "RightBar"
            )
            all_panels_enabled = False
            self.right_panel.present()
        if "--rightbar-apps" in self.args:
            self.right_panel.set_content(self.dockbar_config)
        if "--rightbar-workspaces" in self.args:
            self.right_panel.set_content(workspace_buttons)
        if "--rightbar-todo" in self.args:
            self.right_panel.set_content(self.todo_label_box)

        if [i for i in self.args if "leftbar" in i]:
            self.dockbar_config, workspace_buttons = self.create_widgets(
                "vertical", "LeftBar"
            )
            all_panels_enabled = False
            self.left_panel.present()
        if "--leftbar-apps" in self.args:
            self.left_panel.set_content(self.dockbar_config)
        if "--leftbar-workspaces" in self.args:
            self.left_panel.set_content(workspace_buttons)
        if "--leftbar-todo" in self.args:
            self.left_panel.set_content(self.todo_label_box)

        if [i for i in self.args if "bottombar" in i]:
            self.dockbar_config, workspace_buttons = self.create_widgets(
                "horizontal", "BottomBar"
            )
            all_panels_enabled = False
            self.bottom_panel.present()
        if "--bottombar-apps" in self.args:
            self.bottom_panel.set_content(self.dockbar_config)
        if "--bottombar-workspaces" in self.args:
            self.bottom_panel.set_content(workspace_buttons)
        if "--bottombar-todo" in self.args:
            self.bottom_panel.set_content(self.todo_label_box)

        # gestures

        self.utils.CreateGesture(self.todo_button, 1, self.take_note_app)
        self.utils.CreateGesture(self.clock_box, 1, self.notify_client)
        self.utils.CreateGesture(self.window_title, 1, self.window_notes)
        self.utils.CreateGesture(self.tbclass, 1, self.dock.dockbar_append)
        self.utils.CreateGesture(self.tbclass, 3, self.window_notes)
        self.utils.CreateGesture(self.tbSIGKILL, 1, self.sigkill_activewindow)
        self.utils.CreateGesture(self.tbvol, 1, self.toggle_mute_from_sink)
        #self.utils.CreateGesture(
        #    self.top_panel_box_left, 1, self.left_gesture_left_click
        #)
        self.utils.CreateGesture(
            self.top_panel_box_left, 2, self.left_gesture_middle_click
        )
        self.utils.CreateGesture(
            self.top_panel_box_left, 3, self.left_gesture_right_click
        )
        # self.utils.CreateGesture(self.top_panel_box_center, 1, self.center_gesture_left_click)
        self.utils.CreateGesture(
            self.top_panel_box_center, 2, self.center_gesture_middle_click
        )
        self.utils.CreateGesture(
            self.top_panel_box_center, 3, self.center_gesture_right_click
        )
        self.utils.CreateGesture(
            self.top_panel_box_right, 1, self.right_gesture_left_click
        )
        self.utils.CreateGesture(
            self.top_panel_box_right, 2, self.left_gesture_middle_click
        )
        self.utils.CreateGesture(
            self.top_panel_box_right, 3, self.left_gesture_right_click
        )

        # show all panels
        if all_panels_enabled:
            print("okay" * 100)

            self.dock.do_start()
            self.top_panel.present()
            self.right_panel.present()
            # self.left_panel.present()
            self.top_panel_background.present()
            print("okay" * 100)

    def mullvad_status(self):
        o = check_output("mullvad status".split()).decode()
        if "Disconnected" in o:
            mullvad = self.menus["VPN"]
            mullvad.set_label("VPN Disconnected")
        if "Connected" in o:
            mullvad = self.menus["VPN"]
            mullvad.set_label("VPN")

        return True

    def take_note_app(self, *_):
        with open(self.topbar_config, "r") as f:
            config = toml.load(f)
        self.utils.run_app(config["take_note_app"]["cmd"])

    def sink_cards_info(self):
        pactl = "pactl list sinks short".split()
        sink_inputs = check_output(pactl).decode()
        cards = sink_inputs.split("\n")
        for card in cards:
            try:
                card_id = card.split("alsa")[0].strip()
                card_name = card.split("\talsa_output.")[1].split("\t")[0]
                card_status = card.split("\talsa_output.")[1].split("\t")[3]
                info = {}
                info["card_id"] = card_id
                info["card_name"] = card_name
                info["card_status"] = card_status
                return info
            except Exception as e:
                print(e)
        return None

    # def on_volume_value_changed(self, volumebutton, value):
    # print(value)

    def HyprlandInstance(self):
        return Hyprland()

    def get_monitor_info(self):
        screen = Gdk.Display.get_default()
        monitors = screen.get_monitors()
        monitor_info = {}
        for monitor in monitors:
            monitor_width = monitor.get_geometry().width
            monitor_height = monitor.get_geometry().height
            name = monitor.props.connector
            monitor_info[name] = [monitor_width, monitor_height]
        return monitor_info

    def HyprInfo(self):
        info = {}
        info["window_class"] = self.instance.get_active_window().initial_wm_class
        info["address"] = self.instance.get_active_window().address
        return info

    def create_widgets(self, orientation, class_style):
        dockbar = self.utils.CreateFromAppList(
            orientation, self.dockbar_config, class_style
        )
        workspace_buttons = self.utils.CreateFromAppList(
            orientation, self.workspace_list_config, class_style
        )
        return dockbar, workspace_buttons

    def todo_txt(self):
        todo = os.path.join(self.home, "Documentos", "todo.txt")
        txt = open(todo, "r").readlines()[-1]
        self.todo_button.set_label(txt.strip())
        return True

    def on_button_press_event(self, widget, event):
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            return True

    def right_side_middle_click(self, gesture, data, x, y):
        Popen("kitty".split())

    def scroll_event(self, controller, _dx, dy):
        # mouse whell down is 1.0, -1.0 wheel up
        if dy > 0:
            self.utils.run_app("pactl -- set-sink-volume 0 -8%")
        else:
            self.utils.run_app("pactl -- set-sink-volume 0 +8%")

    def left_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def left_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def left_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["center_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["center_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def center_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["left_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_left_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["left_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_right_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["right_click"]
        self.utils.run_app(cmd, True)

    def right_gesture_middle_click(self, gesture, data, x, y):
        cmd = self.panel_cfg["right_side_gestures"]["middle_click"]
        self.utils.run_app(cmd, True)

    def NewMenu(self):
        with open(self.menu_config, "r") as f:
            menu_toml = toml.load(f)
            menu_buttons = {}
        for m in menu_toml:
            if m == "icons":
                continue
            actions = Gio.Menu()
            btn = Gtk.MenuButton(label=m)
            btn.add_css_class("NewMenu")
            menu_buttons[m] = btn
            for item in menu_toml[m].values():
                name = item[0]["name"]
                action = item[0]["cmd"].replace(" ", "________")
                actions.append(name, action)
                btn.install_action(action, None, self.menu_run_action)
                btn.set_menu_model(actions)
                btn.set_icon_name(menu_toml["icons"][m])
        return menu_buttons

    def sigkill_activewindow(self, *_):
        pid = self.instance.get_active_window().pid
        cmd = "kill -9 {0}".format(pid)
        self.utils.run_app(cmd)

    def menu_run_action(self, action, param, something):
        param = param.replace("________", " ")
        self.utils.run_app(param)

    def update_clock(self):
        self.clock_button.set_label(datetime.now().strftime("%d %A %H:%M"))
        return True

    def load_topbar_config(self):
        with open(self.topbar_config, "r") as f:
            return toml.load(f)

    def clean_pid_store(self):
        # [optimization]
        # every 10 minutes check for non-existent pids and clean the dict
        for pid in self.psutil_store.keys():
            if pid not in self.pid_list:
                del self.psutil_store[pid]

    def copy_to_clipboard(self, *_):
        # lazy to not use wl-copy
        self.utils.run_app("wl-copy {0}".format(self.instance.get_active_window().pid))

    def sink_input_info(self):
        pactl = "pactl list sink-inputs".split()
        sink_inputs = check_output(pactl).decode()
        sinklist = sink_inputs.split("Sink Input #")
        info = {}
        info["sinklist"] = sinklist
        return info

    def toggle_mute_from_sink(self, *_):
        pid = self.instance.get_active_window().pid
        info = self.sink_input_info()
        sinklist = info["sinklist"]
        for sink in sinklist:
            if 'application.process.id = "{0}"'.format(pid) in sink:
                sink = sink.split("\n")[0]
                self.utils.run_app("pactl set-sink-input-mute {0} toggle".format(sink))

    def notify_client(self, *_):
        self.utils.run_app("swaync-client -t")

    def disk_usage_by_pid(self):
        pid = self.instance.get_active_window().pid
        p = psutil.Process(pid)
        io_counters = p.io_counters()
        disk_usage_process = io_counters[2] + io_counters[3]  # read_bytes + write_bytes
        return int(round(disk_usage_process / (1024**2), 2))

    def window_notes(self, *_):
        aw = self.instance.get_active_window()
        ititle = aw.initial_title.lower()
        wm_class = aw.initial_wm_class.lower()
        title = aw.title
        if "firefox" in wm_class and "." in title:
            wm_class = title.split()[0]

        if ititle == "zsh":
            wm_class = title.split()[0]

        with open(self.window_notes_config, "r") as f:
            wtoml = toml.load(f)

        new_data = {wm_class: {"initial_title": ititle, "title": title.lower()}}
        updated_data = ChainMap(new_data, wtoml)

        with open(self.window_notes_config, "w") as f:
            toml.dump(updated_data, f)

        filepath = "/home/neo/Notes/{0}.md".format(wm_class)
        cmd = "marktext {0}".format(filepath)
        if not os.path.isfile(filepath):
            Path(filepath).touch()
        print(cmd)
        self.utils.run_app(cmd)

    def output_loop(self, output, label):
        output = check_output(output.split()).decode().strip()
        label.set_markup(output)
        GLib.Source.remove(self.exec_once)
        return True

    def create_cmd_label(self, output, position, css_class, refresh):
        label = Gtk.Label()
        box = Gtk.Box()
        box.set_halign(Gtk.Align.END)
        box.set_hexpand(False)
        box.set_baseline_position(Gtk.BaselinePosition.BOTTOM)
        box.add_css_class(css_class)
        label.add_css_class(css_class)
        box.append(label)
        if position == "left":
            self.top_panel_box_left.append(box)
        if position == "right":
            self.top_panel_box_systray.append(box)
        if position == "center":
            self.clock_box.append(box)
        self.exec_once = GLib.timeout_add(1000, lambda: self.output_loop(output, label))
        GLib.timeout_add(refresh, lambda: self.output_loop(output, label))

    def cmd_output(self):
        with open(self.cmd_config, "r") as f:
            cmd_toml = toml.load(f)
        for t in cmd_toml:
            cmd = cmd_toml[t]["cmd"]
            position = cmd_toml[t]["position"]
            refresh = cmd_toml[t]["refresh"]
            css_class = cmd_toml[t]["css_class"]
            self.create_cmd_label(cmd, position, css_class, refresh)

    def volume_watch(self):
        with pulsectl.Pulse("volume-increaser") as pulse:
            for sink in pulse.sink_list():
                if "running" in str(sink.state):
                    volume = round(sink.volume.values[0] * 100)
                    self.tbvol.set_label("Volume: {0}%".format(volume))
                    self.tbcard.set_label("{0}".format(sink.description))

    def update_widgets(self):
        try:
            active_window = self.instance.get_active_window()
            initial_title = active_window.initial_title
            title = active_window.title[0:100]
            if "www." in title:
                title = title.split("www.")[1]
            workspace_id = active_window.workspace_id
            pid = active_window.pid
            wclass = active_window.initial_wm_class.lower()
            try:
                # exclusive try because if it fails, will not set the icon at all
                wclass = self.panel_cfg["change_icon_title"][wclass]
            except Exception as e:
                # print(e)
                pass

            if pid not in self.psutil_store.keys():
                process = psutil.Process(pid)
                self.psutil_store[pid] = process

            mem_usage = self.utils.convert_size(
                int(self.psutil_store[pid].memory_info().rss)
            )
            exe = self.psutil_store[pid].exe()
            cpu_usage = int(self.psutil_store[pid].cpu_percent())
            if " — " in title:
                title = title.split(" — ")[0]
            title = "{0}".format(title)
            self.window_title.set_label("{0}".format(title))
            self.tbworkspace.set_label("W: {0}".format(workspace_id))
            self.tbpid.set_label("PID: {0}".format(pid))
            self.tbclass.set_label("{0}".format(wclass))
            self.tbcpusage.set_label("CPU: {0}%".format(cpu_usage))
            self.tbmemusage.set_label("MEM: {0}".format(mem_usage))
            self.tbexe.set_label("Exe: {0}".format(exe))
            self.tbdiskusage.set_label("Disk: {0}MB".format(self.disk_usage_by_pid()))
            self.volume_watch()
            self.window_title.set_icon_name(wclass)
            self.tbclass.set_icon_name(wclass)
            if initial_title == "zsh":
                label = title.split(" ")[0]
                icon_exist = [i for i in self.icon_theme_list if label in i]
                if icon_exist:
                    self.window_title.set_icon_name(label)
                    self.tbclass.set_icon_name("{0}".format(label))
            icon_exist = [i for i in self.icon_theme_list if wclass in i]
            if not icon_exist:
                icon = icon_exist[-1]
                self.window_title.set_icon_name(icon)
                self.tbclass.set_icon_name(icon)
        except Exception as e:
            # print(e)
            pass

        return True


app = Panel(application_id="com.hyprpanel.GtkApplication")

app.run(None)

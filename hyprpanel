#!/usr/bin/env python3
import os
os.environ["GI_TYPELIB_PATH"] = "/usr/include/hyprpanel/src"

from ctypes import CDLL
CDLL('libgtk4-layer-shell.so')
from subprocess import Popen
from subprocess import check_output

import gi
gi.require_version("Gtk", "4.0")
gi.require_version('Adw', '1')
gi.require_version('Gtk4LayerShell', '1.0')

from gi.repository import Gtk
from gi.repository import Gtk4LayerShell as LayerShell
import asyncio
from gi.repository import Gtk, Adw, GLib, Gio, Gdk
from datetime import datetime
import json
import sys 
import importlib
spam_loader  = importlib.util.find_spec('hyprpy')
found = spam_loader is not None

if not found:
    print("Module hyprpy not found, try | pip install hyprpy | and try again")
    sys.exit()

from hyprpy import Hyprland
from multiprocessing import Process
from hyprpy.utils.signals import Signal
import psutil
import math
import pulsectl


args = sys.argv
home = os.path.expanduser('~') 
config_path = os.path.join(home, ".config/hyprpanel")
app_list_config = os.path.join(config_path, "app.list")
style_css_config = os.path.join(config_path, "style.css")
workspace_list_config = os.path.join(config_path, "workspace.list")
panel_config = os.path.join(config_path, "panel.cfg")
menu_config = os.path.join(config_path, "menu.cfg")
psutil_store = {}



def window_changed(sender, **kwargs):
    window = sender.get_active_window()
    title = window.title
    app = Panel(application_id="com.example.GtkApplication")
    app.window_title.set_markup(title)
    try:
        print(window.title, kwargs)
    except: 
        pass
     

def run(app):
    if ";" in app:
        for line in app.split(";"):
            try:
                Popen(line.split(), start_new_session=True)
            except:
                pass
    else:
        Popen(app.split(), start_new_session=True)

def CreateButton(icon, app, Class_Style):
    box = Gtk.Box(spacing=0)
    icon = Gtk.Image(icon_name=icon)
    box.append(icon)
    box.add_css_class(Class_Style)
    button = Gtk.Button(child=box)
    button.add_css_class(Class_Style + "Button")
    if type(app) == str:
        button.connect('clicked', lambda x: run(app))
    else:
        button.connect('clicked', lambda x: app.popup())
        
    return button

def CreatFromAppList(orientation, app_list, class_style):
    box = Gtk.Box(spacing=0, orientation=orientation)
    with(open(app_list) as applist):
          for i in reversed(applist.readlines()):
              if not ":" in i:
                  continue
              app = i.split(":")[0].strip()
              icon = i.split(":")[1].strip()
              button = CreateButton(icon, app, class_style)
              box.append(button)
    return box


def convert_size(size_bytes):
   if size_bytes == 0:
       return "0B"
   size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
   i = int(math.floor(math.log(size_bytes, 1024)))
   p = math.pow(1024, i)
   s = round(size_bytes / p, 2)
   return "%s %s" % (s, size_name[i])


def buttons_for_background(class_style, icon_name):
    tbtn_title_b =  Adw.ButtonContent()
    tbtn_title_b.set_icon_name(icon_name)
    tbtn_title_b.add_css_class(class_style)
    return tbtn_title_b

def CreateGesture(button, button_number, callback):
        gesture = Gtk.GestureClick.new()
        gesture.connect("pressed", callback)
        gesture.connect("released", callback)     
        gesture.set_button(button_number)
        button.add_controller(gesture)
        
def CreatePanel(app, anchor, layer, exclusive, width, height, class_style):
    window = Adw.Window(application=app)
    window.set_default_size(width, height)

    window.add_css_class(class_style)

    LayerShell.init_for_window(window)
    if(anchor == "LEFT"):
        LayerShell.set_anchor(window, LayerShell.Edge.LEFT, True)
    if(anchor == "RIGHT"):
        LayerShell.set_anchor(window, LayerShell.Edge.RIGHT, True)
    if(anchor == "TOP"):
        LayerShell.set_anchor(window, LayerShell.Edge.TOP, True)
    if(anchor == "BOTTOM"):
        LayerShell.set_anchor(window, LayerShell.Edge.BOTTOM, True)
    LayerShell.set_margin(window, LayerShell.Edge.BOTTOM, 0)
    LayerShell.set_margin(window, LayerShell.Edge.TOP, 0)
    if class_style == "TopBarBackground":
        LayerShell.set_margin(window, LayerShell.Edge.BOTTOM, 4)
        LayerShell.set_margin(window, LayerShell.Edge.TOP, 4)
        
    if(layer == "BOTTOM"):
        LayerShell.set_layer (window, LayerShell.Layer.BOTTOM)
    if(layer == "TOP"):
        LayerShell.set_layer (window, LayerShell.Layer.TOP)
    if(exclusive == True):
        LayerShell.auto_exclusive_zone_enable(window)

        
    return window



 
class Panel(Adw.Application):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.connect('activate', self.on_activate)
        self.bottom_panel = None
        self.right_panel = None
        self.left_panel = None
        self.top_panel = None
        self.top_panel_background = None
        self.top_panel_box_left = Gtk.Box(spacing=10)
        self.top_panel_box_right = Gtk.Box(spacing=6)      
        self.top_panel_box_center = Gtk.Box(spacing=6)     
        self.top_panel_box_full = Gtk.Box(spacing=20) 
        self.top_panel_box_full.prepend(self.top_panel_box_right)
        self.top_panel_box_full.prepend(self.top_panel_box_center)
        self.top_panel_box_full.prepend(self.top_panel_box_left)

        self.panel_cfg = self.load_panel_config()
        self.monitor_width = 0
        self.monitor_height = 0
        self.toggle_mute = {}
        self.volume = 0
        

    def on_activate(self, app):
        self.top_panel_box_left .add_css_class("top_panel_box_left")
        self.top_panel_box_right .add_css_class("top_panel_box_right")  
        self.top_panel_box_center .add_css_class("top_panel_box_center")     
        self.top_panel_box_center .props.halign = Gtk.Align.FILL  
        self.top_panel_box_full .add_css_class("top_panel_box_full")     
        panel_on_top = "TOP"
        exclusive = True
        all_panels_enabled = True
        self.instance = self.HyprlandInstance()
        default_panel = True
        


    
        settings_window = Adw.PreferencesWindow()
        
        #get monitor info and set the width, height for the panel
        monitor_info = self.get_monitor_info()
        for monitor_name in monitor_info:
            if self.instance.get_monitor_by_name(name=monitor_name).is_focused:
                self.monitor_width, self.monitor_height = monitor_info[monitor_name]

        
        if "--custom" in args:
            default_panel = False
        
        if "--background" in args:
            panel_on_top = "BOTTOM"
            exclusive = False
          
          
        #panel.cfg setup       
        with open(panel_config) as f:
            data = f.read()
            panel_json = json.loads(data)
            for p in panel_json:
                    if "bottom" == p:
                        exclusive = True
                        if panel_json[p]["Exclusive"] == "False":
                            exclusive = False   

                        position = panel_json[p]["position"]                  
                        self.bottom_panel = CreatePanel(app, "BOTTOM", position, exclusive, 32, 0, "BottomBar")
                    if "right" == p:
                        exclusive = True
                        if panel_json[p]["Exclusive"] == "False":
                            exclusive = False    
                        position = panel_json[p]["position"]                
                        self.right_panel = CreatePanel(app, "RIGHT",  position, exclusive, 0, 32, "RightBar")                   
                    if "left" == p:
                        exclusive = True
                        if panel_json[p]["Exclusive"] == "False":
                            exclusive = False   
                        position = panel_json[p]["position"] 
                        self.left_panel = CreatePanel(app, "LEFT", position, exclusive, 0, 32, "LeftBar")                
                    if "top" == p:
                        exclusive = True
                        if panel_json[p]["Exclusive"] == "False":
                            exclusive = False    
                        position = panel_json[p]["position"]
                        self.top_panel = CreatePanel(app, "TOP", position, exclusive, self.monitor_width, 24, "TopBar")
                    if "top_background" == p:
                        exclusive = True
                        if panel_json[p]["Exclusive"] == "False":
                            exclusive = False    
                        position = panel_json[p]["position"]
                        self.top_panel_background = CreatePanel(app, "TOP", position, exclusive, self.monitor_width, 48, "TopBarBackground")
                        
                                
        
        #load css
        css_provider = Gtk.CssProvider()
        css_provider.load_from_file(Gio.File.new_for_path(style_css_config))
        Gtk.StyleContext.add_provider_for_display(Gdk.Display.get_default(), css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
        
        
        #clock widget
        self.clock_box = Gtk.Box()
        self.clock_box.add_css_class("Clock")
        self.clock_button = CreateButton("clock", "thunderbird -calendar", "ClockButton")
        self.clock_box.append(self.clock_button)
        
        
        #close, maximize, full screen buttons
        close_button = CreateButton("window-close-symbolic", "hyprctl dispatch killactive", "close_button")
        fullscreen_button = CreateButton("gtk-fullscreen", "hyprctl dispatch fullscreen", "fullscreen_button")
        self.top_panel_box_left.append(close_button)  
        self.top_panel_box_left.append(fullscreen_button)  
        
        
        

        GLib.timeout_add(1000, self.update_clock)
        GLib.timeout_add(200, self.update_title)
        GLib.timeout_add(10000, self.mullvad_status)
        GLib.timeout_add(600000, self.clean_pid_store)
        



        #volumebutton = Gtk.VolumeButton.new()
        #volumebutton.connect("value-changed",self.on_volume_value_changed)
        #volbox.append(volumebutton)

        #click gestures
        gesture_left_space = " " * (round(self.monitor_width /  13))
        label_gesture_left = Gtk.Label(label=gesture_left_space)
        label_gesture_left.set_wrap(True)
        gesture_right_click = Gtk.GestureClick.new()
        gesture_right_click.connect("pressed", self.press)
        gesture_right_click.connect("released", self.release)     
        gesture_right_click.set_button(3)
        gesture_left_click = Gtk.GestureClick.new()
        gesture_left_click.connect("pressed", self.press_leftButton)
        gesture_left_click.connect("released", self.release_leftButton)
        gesture_left_click.set_button(1)
        label_gesture_left.set_valign(True)
        label_gesture_left.add_controller(gesture_right_click)
        label_gesture_left.add_controller(gesture_left_click)
        
           
        # notes label
        self.todo_label = Gtk.Label()
        todo = os.path.join(home, "Documentos", "todo.txt")
        txt = open(todo, "r").readlines()[-1]
        self.todo_label.set_markup("  Last todo.txt Note: " + txt + "   ")
        GLib.timeout_add(600000, self.todo_txt)

        self.menus = self.NewMenu()
        #create menus
        for menu in self.menus.values():
            self.top_panel_box_left.append(menu)       
             

       
        #gesture space for clicks 
        self.top_panel_box_left.append(label_gesture_left)
        self.top_panel_box_left.append(self.clock_box)
         
        self.iconbox = Gtk.Box(spacing=0)
        self.icon_title = CreateButton("kitty", "nwg-drawer", "kitty")
        self.iconbox.append(self.icon_title)
        #self.top_panel_box_left.append(self.iconbox)
        
        #setup window title
        self.window_title = Adw.ButtonContent()
        self.top_panel_box_left.append(self.window_title)
        self.window_title.add_css_class("WindowTitle")
        #self.window_title.connect("clicked", lambda x: run("swaync-client -t"))
        
        #setup label for top bar background
        self.tbbox = Gtk.Box(spacing=20)
        self.tblabelspace = Gtk.Label(label="    ")
        self.tbworkspace = buttons_for_background("tbworkspace", "workspace-symbolic")
        self.tbpid = buttons_for_background("tbpid", "view-process-tree")  
        self.tbpid_gesture = CreateGesture(self.tbpid, 1, self.copy_to_clipboard)
        self.tbclass = buttons_for_background("tbclass", "cs-windows-symbolic")     
        self.tbcpusage = buttons_for_background("tbcpusage", "cpu-frequency-indicator") 
        self.tbmemusage = buttons_for_background("tbmemusage","indicator-sensors-memory") 
        self.tbsinkinput = buttons_for_background("tbsinkinput", "multimedia-volume-control-symbolic") 
        self.tbSIGKILL = buttons_for_background("tbSIGKILL", "window-close-symbolic") 
        self.tbdiskusage = buttons_for_background("tbdiskusage", "disk-check-symbolic") 
        self.tbvol = buttons_for_background("tbvol", "multimedia-volume-control-symbolic") 
        self.tbcard = buttons_for_background("tbvoltbcard", "audio-card") 
        self.tbdiskusage.set_label("Disk Usage")
        self.tbsinkinput.set_label("Toggle Mute")
        self.tbvol.set_label("Volume")
        self.tbSIGKILL.set_label("SIGKILL")
        self.tbexe = buttons_for_background("tbexe", "exec")
        self.tbbox.append(self.tblabelspace)
        self.tbbox.append(self.tbworkspace)
        self.tbbox.append(self.tbclass)   
        self.tbbox.append(self.tbpid)
        self.tbbox.append(self.tbSIGKILL)
        #self.tbbox.append(self.tbsinkinput) 
        #self.tbbox.append(self.tbcard) 
        self.tbbox.append(self.tbvol)  
        self.tbbox.append(self.tbcpusage) 
        self.tbbox.append(self.tbmemusage)   
        #self.tbbox.append(self.tbexe)  
        self.tbbox.append(self.tbdiskusage)
        CreateGesture(self.tbSIGKILL, 1, self.sigkill_activewindow)
        CreateGesture(self.tbvol, 1, self.toggle_mute_from_sink)
        
        #self.tbSIGKILL.connect("clicked", self.sigkill_activewindow)
        self.top_panel_background.set_content(self.tbbox)

        #gestures right side
        gesture_right_space = " " * round(self.monitor_width / 10)
        if self.monitor_width < 2000:
            gesture_right_space = " " * round(self.monitor_width / 20)
        label_gesture_right = Gtk.Label(label=gesture_right_space)
        label_gesture_right.set_wrap(True)
        gesture_right_click = Gtk.GestureClick.new()
        gesture_right_click.connect("pressed", self.press)
        gesture_right_click.connect("released", self.release)
        gesture_right_click.set_button(3)
        gesture_middle_click = Gtk.GestureClick.new()
        gesture_middle_click.connect("pressed", self.right_side_middle_click)
        gesture_middle_click.connect("released", self.release)
        gesture_middle_click.set_button(2)
        gesture_left_click = Gtk.GestureClick.new()
        gesture_left_click.connect("pressed", self.press_leftButton)
        gesture_left_click.connect("released", self.release_leftButton)
        gesture_left_click.set_button(1)
        

        label_gesture_right.add_controller(gesture_right_click)
        label_gesture_right.add_controller(gesture_left_click)
        label_gesture_right.add_controller(gesture_middle_click)
        EventScroll = Gtk.EventControllerScroll.new(Gtk.EventControllerScrollFlags.BOTH_AXES)
        EventScroll.connect("scroll", self.scroll_event)
        label_gesture_right.add_controller(EventScroll)
        self.top_panel_box_right.append(label_gesture_right)

        

                
        #create panel buttons
        if default_panel:
            app_list = CreatFromAppList("horizontal", app_list_config, "BottomBar")
            workspace_buttons = CreatFromAppList("vertical", workspace_list_config, "RightBar")
            self.bottom_panel.set_content(app_list)
            self.top_panel.set_content(self.top_panel_box_full)
            self.right_panel.set_content(workspace_buttons) 
                    
        if [i for i in args if "topbar" in i]:  
            app_list, workspace_buttons = self.create_widgets("horizontal", "TopBar")         
            all_panels_enabled = False
            self.top_panel.present()
            
        #this whole section is intended to setup custom panel positions and widgets    
        if "--topbar-apps" in args:
                self.top_panel.set_content(app_list)
        if "--topbar-workspaces" in args:
                self.top_panel.set_content(workspace_buttons)
        if "--topbar-todo" in args:
                self.top_panel.set_content(todo_label_box)

        if [i for i in args if "rightbar" in i]:  
            app_list, workspace_buttons = self.create_widgets("vertical", "RightBar")         
            all_panels_enabled = False
            right_panel.present()
        if "--rightbar-apps" in args:
            self.right_panel.set_content(app_list)
        if "--rightbar-workspaces" in args:
            self.right_panel.set_content(workspace_buttons)
        if "--rightbar-todo" in args:
            self.right_panel.set_content(todo_label_box)             
            
        if [i for i in args if "leftbar" in i]:  
            app_list, workspace_buttons = self.create_widgets("vertical", "LeftBar")          
            all_panels_enabled = False
            self.left_panel.present()
        if "--leftbar-apps" in args:
            self.left_panel.set_content(app_list)
        if "--leftbar-workspaces" in args:
            self.left_panel.set_content(workspace_buttons)
        if "--leftbar-todo" in args:
            self.left_panel.set_content(todo_label_box)
            
        if [i for i in args if "bottombar" in i]:  
            app_list, workspace_buttons = self.create_widgets("horizontal", "BottomBar")
            all_panels_enabled = False
            self.bottom_panel.present()
        if "--bottombar-apps" in args:
            self.bottom_panel.set_content(app_list)
        if "--bottombar-workspaces" in args:
            self.bottom_panel.set_content(workspace_buttons)
        if "--bottombar-todo" in args:
            self.bottom_panel.set_content(todo_label_box)

        #show all panels            
        if all_panels_enabled:
            self.top_panel.present()
            self.right_panel.present()
            self.bottom_panel.present()
            self.left_panel.present()
            self.top_panel_background.present()
        

        

                
    def mullvad_status(self):
        o = check_output("mullvad status".split()).decode()
        if "Disconnected" in o:
            mullvad = self.menus["VPN"]
            mullvad.set_label("VPN Disconnected")
        if "Connected" in o:
            mullvad = self.menus["VPN"]
            mullvad.set_label("VPN")
            
        return True

    def sink_cards_info():
        pactl = "pactl list sinks short".split()
        sink_inputs = check_output(pactl).decode()
        cards = sink_inputs.split("\n")
        for card in cards:
            try:
                card_id = card.split("alsa")[0].strip()
                card_name = card.split("\talsa_output.")[1].split("\t")[0]
                card_status = card.split("\talsa_output.")[1].split("\t")[3]
                info = {}
                info["card_id"] = card_id
                info["card_name"] = card_name
                info["card_status"] = card_status
                return info
            except: pass
        return None
    
    def on_volume_value_changed(self,volumebutton,value):
        print(value)
               
    def HyprlandInstance(self):    
        return Hyprland() 

    def get_monitor_info(self):
        screen = Gdk.Display.get_default()
        monitors = screen.get_monitors()
        monitor_info = {}
        for monitor in monitors:
            monitor_width = monitor.get_geometry().width
            monitor_height = monitor.get_geometry().height
            name = monitor.props.connector
            monitor_info[name] = [monitor_width, monitor_height]
        return monitor_info
    

    
    def HyprInfo(self):
        info = {}
        info["window_class"] = self.instance.get_active_window().initial_wm_class
        return info
        
    def create_widgets(self, orientation, class_style):
        app_list = CreatFromAppList(orientation, app_list_config, class_style)
        workspace_buttons = CreatFromAppList(orientation, workspace_list_config, class_style)
        return app_list, workspace_buttons    
            
    def todo_txt(self):
        todo = os.path.join(home, "Documentos", "todo.txt")
        txt = open(todo, "r").readlines()[-1]
        self.todo_label.set_markup("  Last todo.txt Note: " + txt + "   ")
        return True    
    
    def on_button_press_event(self, widget, event):
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            return True
    
    def right_side_middle_click(elf, gesture, data, x, y):
        Popen("kitty".split())
        
    def scroll_event(self, controller, _dx, dy):
        #mouse whell down is 1.0, -1.0 wheel up
        if dy > 0:
            run("pactl -- set-sink-volume 0 -8%")
        else:
            run("pactl -- set-sink-volume 0 +8%")

    def press(self, gesture, data, x, y):
        Popen("python /home/neo/.config/hypr/scripts/workspaces.py".split())
        button = gesture.get_current_button()
        print(button)
        return True
    
    def release(self, *_):
        print("released")
        return True
        
    def press_leftButton(self, gesture, data, x, y):
        Popen("hyprctl dispatch fullscreen 1".split())
        button = gesture.get_current_button()
        print(button)
        return True
    
    def release_leftButton(self, *_):
        print("released")
        return True
        
    def dw_click(self,  gesture, data, x, y):
        button = gesture.get_current_button()
        print(button)

    def NewMenu(self):   
        with open(menu_config) as f:
            data = f.read()
        menu_json = json.loads(data)
        menu_buttons = {}
        for m in menu_json:
            actions = Gio.Menu()
            btn = Gtk.MenuButton(label = m)  
            btn.add_css_class("NewMenu")         
            menu_buttons[m] = btn
            for item in menu_json[m].values():
                name = item[0]["name"]
                action = item[0]["cmd"].replace(" ", "________")
                actions.append(name, action)
                btn.install_action(action, None, self.menu_run_action)
                btn.set_menu_model(actions)         
        return menu_buttons

    def sigkill_activewindow(self, *_):
        pid = self.instance.get_active_window().pid
        cmd = "kill -9 {0}".format(pid)
        run(cmd)

    def menu_run_action(self, action, param, something):
        param = param.replace("________", " ")
        run(param)
        
    def update_clock(self):
        self.clock_button.set_label(datetime.now().strftime('%d %a %H:%M'))
        return True
      
    def load_panel_config(self):
        with open(panel_config) as f:
            data = f.read()
        return json.loads(data)
    
    def clean_pid_store(self):
        #[optimization]
        # every 10 minutes check for non-existent pids and clean the dict
        for pid in psutil_store.keys():
            if pid not in pid_list:
                del psutil_store[pid]
        
    def copy_to_clipboard(self, *_):
        #lazy to not use wl-copy
        run("wl-copy {0}".format(self.instance.get_active_window().pid))    
     
    def sink_input_info(self):
        pid = self.instance.get_active_window().pid
        pactl = "pactl list sink-inputs".split()
        sink_inputs = check_output(pactl).decode()
        sinklist = sink_inputs.split("Sink Input #")
        info = {}
        info["sinklist"] = sinklist
        return info
            
    def toggle_mute_from_sink(self, *_):
        pid = self.instance.get_active_window().pid
        info = self.sink_input_info()
        sinklist = info["sinklist"]
        for sink in sinklist:
            if 'application.process.id = "{0}"'.format(pid) in sink:
                sink = sink.split("\n")[0]
                run("pactl set-sink-input-mute {0} toggle".format(sink))             
                   
    def disk_usage_by_pid(self):
        pid = self.instance.get_active_window().pid
        p = psutil.Process(pid)
        io_counters = p.io_counters() 
        disk_usage_process = io_counters[2] + io_counters[3] # read_bytes + write_bytes
        disk_io_counter = psutil.disk_io_counters()
        disk_total = disk_io_counter[2] + disk_io_counter[3] # read_bytes + write_bytes
        return int(round(disk_usage_process / (1024**2), 2))
    
    def volume_watch(self):
        with pulsectl.Pulse('volume-increaser') as pulse:
            for sink in pulse.sink_list():
                if "running" in str(sink.state):
                    volume = round(sink.volume.values[0] * 100)
                    self.tbvol.set_label("Volume: {0}%".format(volume))
                    self.tbcard.set_label("{0}".format(sink.description))
    
    def update_title(self):
        try:
            active_window = self.instance.get_active_window()
            title = active_window.title
            title = title[0:48]
            workspace_id = active_window.workspace.id
            pid = active_window.pid
            wclass = active_window.initial_wm_class.lower()
            if not pid in psutil_store.keys():
                process = psutil.Process(pid)
                psutil_store[pid] = process

            mem_usage = convert_size(int(psutil_store[pid].memory_info().rss))
            exe = psutil_store[pid].exe()
            cpu_usage = int(psutil_store[pid].cpu_percent())
            if " — " in title:
                title = title.split(" — ")[0]
            title = "W:{0} - {1}".format(workspace_id,  title)
            self.window_title.set_label(title)
            self.tbworkspace.set_label("W: {0}".format(workspace_id))
            self.tbpid.set_label("PID: {0}".format(pid))
            self.tbclass.set_label("{0}".format(wclass))
            self.tbcpusage.set_label("CPU: {0}%".format(cpu_usage))
            self.tbmemusage.set_label("MEM: {0}".format(mem_usage))
            self.tbexe.set_label("Exe: {0}".format(exe))
            self.tbdiskusage.set_label("Disk: {0}MB".format(self.disk_usage_by_pid()))
            self.volume_watch()

            try:
                #exclusive try because if it fails, will not set the icon at all
                wclass = self.panel_cfg["change_icon_title"][wclass]
            except:
                pass
            self.window_title.set_icon_name(wclass)
            self.tbclass.set_icon_name(wclass)
        except:
            pass
        
        return True

   
app = Panel(application_id="com.hyprpanel.GtkApplication")

app.run(None)
